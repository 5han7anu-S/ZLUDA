/* automatically generated by rust-bindgen 0.59.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct hipDeviceArch_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub __bindgen_padding_0: u8,
}
impl hipDeviceArch_t {
    #[inline]
    pub fn hasGlobalInt32Atomics(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasGlobalInt32Atomics(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasGlobalFloatAtomicExch(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasGlobalFloatAtomicExch(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasSharedInt32Atomics(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasSharedInt32Atomics(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasSharedFloatAtomicExch(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasSharedFloatAtomicExch(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasFloatAtomicAdd(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasFloatAtomicAdd(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasGlobalInt64Atomics(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasGlobalInt64Atomics(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasSharedInt64Atomics(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasSharedInt64Atomics(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasDoubles(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasDoubles(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasWarpVote(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasWarpVote(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasWarpBallot(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasWarpBallot(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasWarpShuffle(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasWarpShuffle(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasFunnelShift(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasFunnelShift(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasThreadFenceSystem(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasThreadFenceSystem(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasSyncThreadsExt(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasSyncThreadsExt(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasSurfaceFuncs(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasSurfaceFuncs(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has3dGrid(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has3dGrid(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasDynamicParallelism(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasDynamicParallelism(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hasGlobalInt32Atomics: ::std::os::raw::c_uint,
        hasGlobalFloatAtomicExch: ::std::os::raw::c_uint,
        hasSharedInt32Atomics: ::std::os::raw::c_uint,
        hasSharedFloatAtomicExch: ::std::os::raw::c_uint,
        hasFloatAtomicAdd: ::std::os::raw::c_uint,
        hasGlobalInt64Atomics: ::std::os::raw::c_uint,
        hasSharedInt64Atomics: ::std::os::raw::c_uint,
        hasDoubles: ::std::os::raw::c_uint,
        hasWarpVote: ::std::os::raw::c_uint,
        hasWarpBallot: ::std::os::raw::c_uint,
        hasWarpShuffle: ::std::os::raw::c_uint,
        hasFunnelShift: ::std::os::raw::c_uint,
        hasThreadFenceSystem: ::std::os::raw::c_uint,
        hasSyncThreadsExt: ::std::os::raw::c_uint,
        hasSurfaceFuncs: ::std::os::raw::c_uint,
        has3dGrid: ::std::os::raw::c_uint,
        hasDynamicParallelism: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hasGlobalInt32Atomics: u32 =
                unsafe { ::std::mem::transmute(hasGlobalInt32Atomics) };
            hasGlobalInt32Atomics as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hasGlobalFloatAtomicExch: u32 =
                unsafe { ::std::mem::transmute(hasGlobalFloatAtomicExch) };
            hasGlobalFloatAtomicExch as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hasSharedInt32Atomics: u32 =
                unsafe { ::std::mem::transmute(hasSharedInt32Atomics) };
            hasSharedInt32Atomics as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let hasSharedFloatAtomicExch: u32 =
                unsafe { ::std::mem::transmute(hasSharedFloatAtomicExch) };
            hasSharedFloatAtomicExch as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let hasFloatAtomicAdd: u32 = unsafe { ::std::mem::transmute(hasFloatAtomicAdd) };
            hasFloatAtomicAdd as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let hasGlobalInt64Atomics: u32 =
                unsafe { ::std::mem::transmute(hasGlobalInt64Atomics) };
            hasGlobalInt64Atomics as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let hasSharedInt64Atomics: u32 =
                unsafe { ::std::mem::transmute(hasSharedInt64Atomics) };
            hasSharedInt64Atomics as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let hasDoubles: u32 = unsafe { ::std::mem::transmute(hasDoubles) };
            hasDoubles as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let hasWarpVote: u32 = unsafe { ::std::mem::transmute(hasWarpVote) };
            hasWarpVote as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let hasWarpBallot: u32 = unsafe { ::std::mem::transmute(hasWarpBallot) };
            hasWarpBallot as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let hasWarpShuffle: u32 = unsafe { ::std::mem::transmute(hasWarpShuffle) };
            hasWarpShuffle as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let hasFunnelShift: u32 = unsafe { ::std::mem::transmute(hasFunnelShift) };
            hasFunnelShift as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let hasThreadFenceSystem: u32 = unsafe { ::std::mem::transmute(hasThreadFenceSystem) };
            hasThreadFenceSystem as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let hasSyncThreadsExt: u32 = unsafe { ::std::mem::transmute(hasSyncThreadsExt) };
            hasSyncThreadsExt as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let hasSurfaceFuncs: u32 = unsafe { ::std::mem::transmute(hasSurfaceFuncs) };
            hasSurfaceFuncs as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let has3dGrid: u32 = unsafe { ::std::mem::transmute(has3dGrid) };
            has3dGrid as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let hasDynamicParallelism: u32 =
                unsafe { ::std::mem::transmute(hasDynamicParallelism) };
            hasDynamicParallelism as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " hipDeviceProp"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipDeviceProp_t {
    #[doc = "< Device name."]
    pub name: [::std::os::raw::c_char; 256usize],
    #[doc = "< Size of global memory region (in bytes)."]
    pub totalGlobalMem: usize,
    #[doc = "< Size of shared memory region (in bytes)."]
    pub sharedMemPerBlock: usize,
    #[doc = "< Registers per block."]
    pub regsPerBlock: ::std::os::raw::c_int,
    #[doc = "< Warp size."]
    pub warpSize: ::std::os::raw::c_int,
    #[doc = "< Max work items per work group or workgroup max size."]
    pub maxThreadsPerBlock: ::std::os::raw::c_int,
    #[doc = "< Max number of threads in each dimension (XYZ) of a block."]
    pub maxThreadsDim: [::std::os::raw::c_int; 3usize],
    #[doc = "< Max grid dimensions (XYZ)."]
    pub maxGridSize: [::std::os::raw::c_int; 3usize],
    #[doc = "< Max clock frequency of the multiProcessors in khz."]
    pub clockRate: ::std::os::raw::c_int,
    #[doc = "< Max global memory clock frequency in khz."]
    pub memoryClockRate: ::std::os::raw::c_int,
    #[doc = "< Global memory bus width in bits."]
    pub memoryBusWidth: ::std::os::raw::c_int,
    #[doc = "< Size of shared memory region (in bytes)."]
    pub totalConstMem: usize,
    #[doc = "< Major compute capability.  On HCC, this is an approximation and features may"]
    #[doc = "< differ from CUDA CC.  See the arch feature flags for portable ways to query"]
    #[doc = "< feature caps."]
    pub major: ::std::os::raw::c_int,
    #[doc = "< Minor compute capability.  On HCC, this is an approximation and features may"]
    #[doc = "< differ from CUDA CC.  See the arch feature flags for portable ways to query"]
    #[doc = "< feature caps."]
    pub minor: ::std::os::raw::c_int,
    #[doc = "< Number of multi-processors (compute units)."]
    pub multiProcessorCount: ::std::os::raw::c_int,
    #[doc = "< L2 cache size."]
    pub l2CacheSize: ::std::os::raw::c_int,
    #[doc = "< Maximum resident threads per multi-processor."]
    pub maxThreadsPerMultiProcessor: ::std::os::raw::c_int,
    #[doc = "< Compute mode."]
    pub computeMode: ::std::os::raw::c_int,
    #[doc = "< Frequency in khz of the timer used by the device-side \"clock*\""]
    #[doc = "< instructions.  New for HIP."]
    pub clockInstructionRate: ::std::os::raw::c_int,
    #[doc = "< Architectural feature flags.  New for HIP."]
    pub arch: hipDeviceArch_t,
    #[doc = "< Device can possibly execute multiple kernels concurrently."]
    pub concurrentKernels: ::std::os::raw::c_int,
    #[doc = "< PCI Domain ID"]
    pub pciDomainID: ::std::os::raw::c_int,
    #[doc = "< PCI Bus ID."]
    pub pciBusID: ::std::os::raw::c_int,
    #[doc = "< PCI Device ID."]
    pub pciDeviceID: ::std::os::raw::c_int,
    #[doc = "< Maximum Shared Memory Per Multiprocessor."]
    pub maxSharedMemoryPerMultiProcessor: usize,
    #[doc = "< 1 if device is on a multi-GPU board, 0 if not."]
    pub isMultiGpuBoard: ::std::os::raw::c_int,
    #[doc = "< Check whether HIP can map host memory"]
    pub canMapHostMemory: ::std::os::raw::c_int,
    #[doc = "< DEPRECATED: use gcnArchName instead"]
    pub gcnArch: ::std::os::raw::c_int,
    #[doc = "< AMD GCN Arch Name."]
    pub gcnArchName: [::std::os::raw::c_char; 256usize],
    #[doc = "< APU vs dGPU"]
    pub integrated: ::std::os::raw::c_int,
    #[doc = "< HIP device supports cooperative launch"]
    pub cooperativeLaunch: ::std::os::raw::c_int,
    #[doc = "< HIP device supports cooperative launch on multiple devices"]
    pub cooperativeMultiDeviceLaunch: ::std::os::raw::c_int,
    #[doc = "< Maximum size for 1D textures bound to linear memory"]
    pub maxTexture1DLinear: ::std::os::raw::c_int,
    #[doc = "< Maximum number of elements in 1D images"]
    pub maxTexture1D: ::std::os::raw::c_int,
    #[doc = "< Maximum dimensions (width, height) of 2D images, in image elements"]
    pub maxTexture2D: [::std::os::raw::c_int; 2usize],
    #[doc = "< Maximum dimensions (width, height, depth) of 3D images, in image elements"]
    pub maxTexture3D: [::std::os::raw::c_int; 3usize],
    #[doc = "< Addres of HDP_MEM_COHERENCY_FLUSH_CNTL register"]
    pub hdpMemFlushCntl: *mut ::std::os::raw::c_uint,
    #[doc = "< Addres of HDP_REG_COHERENCY_FLUSH_CNTL register"]
    pub hdpRegFlushCntl: *mut ::std::os::raw::c_uint,
    #[doc = "<Maximum pitch in bytes allowed by memory copies"]
    pub memPitch: usize,
    #[doc = "<Alignment requirement for textures"]
    pub textureAlignment: usize,
    #[doc = "<Pitch alignment requirement for texture references bound to pitched memory"]
    pub texturePitchAlignment: usize,
    #[doc = "<Run time limit for kernels executed on the device"]
    pub kernelExecTimeoutEnabled: ::std::os::raw::c_int,
    #[doc = "<Device has ECC support enabled"]
    pub ECCEnabled: ::std::os::raw::c_int,
    #[doc = "< 1:If device is Tesla device using TCC driver, else 0"]
    pub tccDriver: ::std::os::raw::c_int,
    #[doc = "< HIP device supports cooperative launch on multiple"]
    pub cooperativeMultiDeviceUnmatchedFunc: ::std::os::raw::c_int,
    #[doc = "< HIP device supports cooperative launch on multiple"]
    pub cooperativeMultiDeviceUnmatchedGridDim: ::std::os::raw::c_int,
    #[doc = "< HIP device supports cooperative launch on multiple"]
    pub cooperativeMultiDeviceUnmatchedBlockDim: ::std::os::raw::c_int,
    #[doc = "< HIP device supports cooperative launch on multiple"]
    pub cooperativeMultiDeviceUnmatchedSharedMem: ::std::os::raw::c_int,
    #[doc = "< 1: if it is a large PCI bar device, else 0"]
    pub isLargeBar: ::std::os::raw::c_int,
    #[doc = "< Revision of the GPU in this device"]
    pub asicRevision: ::std::os::raw::c_int,
    #[doc = "< Device supports allocating managed memory on this system"]
    pub managedMemory: ::std::os::raw::c_int,
    #[doc = "< Host can directly access managed memory on the device without migration"]
    pub directManagedMemAccessFromHost: ::std::os::raw::c_int,
    #[doc = "< Device can coherently access managed memory concurrently with the CPU"]
    pub concurrentManagedAccess: ::std::os::raw::c_int,
    #[doc = "< Device supports coherently accessing pageable memory"]
    #[doc = "< without calling hipHostRegister on it"]
    pub pageableMemoryAccess: ::std::os::raw::c_int,
    #[doc = "< Device accesses pageable memory via the host's page tables"]
    pub pageableMemoryAccessUsesHostPageTables: ::std::os::raw::c_int,
}
impl hipMemoryType {
    #[doc = "< Memory is physically located on host"]
    pub const hipMemoryTypeHost: hipMemoryType = hipMemoryType(0);
}
impl hipMemoryType {
    #[doc = "< Memory is physically located on device. (see deviceId for specific"]
    #[doc = "< device)"]
    pub const hipMemoryTypeDevice: hipMemoryType = hipMemoryType(1);
}
impl hipMemoryType {
    #[doc = "< Array memory, physically located on device. (see deviceId for specific"]
    #[doc = "< device)"]
    pub const hipMemoryTypeArray: hipMemoryType = hipMemoryType(2);
}
impl hipMemoryType {
    #[doc = "< Not used currently"]
    pub const hipMemoryTypeUnified: hipMemoryType = hipMemoryType(3);
}
#[repr(transparent)]
#[doc = " Memory type (for pointer attributes)"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hipMemoryType(pub ::std::os::raw::c_uint);
#[doc = " Pointer attributes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipPointerAttribute_t {
    pub memoryType: hipMemoryType,
    pub device: ::std::os::raw::c_int,
    pub devicePointer: *mut ::std::os::raw::c_void,
    pub hostPointer: *mut ::std::os::raw::c_void,
    pub isManaged: ::std::os::raw::c_int,
    pub allocationFlags: ::std::os::raw::c_uint,
}
impl hipError_t {
    #[doc = "< Successful completion."]
    pub const hipSuccess: hipError_t = hipError_t(0);
}
impl hipError_t {
    #[doc = "< One or more of the parameters passed to the API call is NULL"]
    #[doc = "< or not in an acceptable range."]
    pub const hipErrorInvalidValue: hipError_t = hipError_t(1);
}
impl hipError_t {
    pub const hipErrorOutOfMemory: hipError_t = hipError_t(2);
}
impl hipError_t {
    #[doc = "< Memory allocation error."]
    pub const hipErrorMemoryAllocation: hipError_t = hipError_t(2);
}
impl hipError_t {
    pub const hipErrorNotInitialized: hipError_t = hipError_t(3);
}
impl hipError_t {
    pub const hipErrorInitializationError: hipError_t = hipError_t(3);
}
impl hipError_t {
    pub const hipErrorDeinitialized: hipError_t = hipError_t(4);
}
impl hipError_t {
    pub const hipErrorProfilerDisabled: hipError_t = hipError_t(5);
}
impl hipError_t {
    pub const hipErrorProfilerNotInitialized: hipError_t = hipError_t(6);
}
impl hipError_t {
    pub const hipErrorProfilerAlreadyStarted: hipError_t = hipError_t(7);
}
impl hipError_t {
    pub const hipErrorProfilerAlreadyStopped: hipError_t = hipError_t(8);
}
impl hipError_t {
    pub const hipErrorInvalidConfiguration: hipError_t = hipError_t(9);
}
impl hipError_t {
    pub const hipErrorInvalidPitchValue: hipError_t = hipError_t(12);
}
impl hipError_t {
    pub const hipErrorInvalidSymbol: hipError_t = hipError_t(13);
}
impl hipError_t {
    #[doc = "< Invalid Device Pointer"]
    pub const hipErrorInvalidDevicePointer: hipError_t = hipError_t(17);
}
impl hipError_t {
    #[doc = "< Invalid memory copy direction"]
    pub const hipErrorInvalidMemcpyDirection: hipError_t = hipError_t(21);
}
impl hipError_t {
    pub const hipErrorInsufficientDriver: hipError_t = hipError_t(35);
}
impl hipError_t {
    pub const hipErrorMissingConfiguration: hipError_t = hipError_t(52);
}
impl hipError_t {
    pub const hipErrorPriorLaunchFailure: hipError_t = hipError_t(53);
}
impl hipError_t {
    pub const hipErrorInvalidDeviceFunction: hipError_t = hipError_t(98);
}
impl hipError_t {
    #[doc = "< Call to hipGetDeviceCount returned 0 devices"]
    pub const hipErrorNoDevice: hipError_t = hipError_t(100);
}
impl hipError_t {
    #[doc = "< DeviceID must be in range 0...#compute-devices."]
    pub const hipErrorInvalidDevice: hipError_t = hipError_t(101);
}
impl hipError_t {
    pub const hipErrorInvalidImage: hipError_t = hipError_t(200);
}
impl hipError_t {
    #[doc = "< Produced when input context is invalid."]
    pub const hipErrorInvalidContext: hipError_t = hipError_t(201);
}
impl hipError_t {
    pub const hipErrorContextAlreadyCurrent: hipError_t = hipError_t(202);
}
impl hipError_t {
    pub const hipErrorMapFailed: hipError_t = hipError_t(205);
}
impl hipError_t {
    #[doc = "< Produced when the IPC memory attach failed from ROCr."]
    pub const hipErrorMapBufferObjectFailed: hipError_t = hipError_t(205);
}
impl hipError_t {
    pub const hipErrorUnmapFailed: hipError_t = hipError_t(206);
}
impl hipError_t {
    pub const hipErrorArrayIsMapped: hipError_t = hipError_t(207);
}
impl hipError_t {
    pub const hipErrorAlreadyMapped: hipError_t = hipError_t(208);
}
impl hipError_t {
    pub const hipErrorNoBinaryForGpu: hipError_t = hipError_t(209);
}
impl hipError_t {
    pub const hipErrorAlreadyAcquired: hipError_t = hipError_t(210);
}
impl hipError_t {
    pub const hipErrorNotMapped: hipError_t = hipError_t(211);
}
impl hipError_t {
    pub const hipErrorNotMappedAsArray: hipError_t = hipError_t(212);
}
impl hipError_t {
    pub const hipErrorNotMappedAsPointer: hipError_t = hipError_t(213);
}
impl hipError_t {
    pub const hipErrorECCNotCorrectable: hipError_t = hipError_t(214);
}
impl hipError_t {
    pub const hipErrorUnsupportedLimit: hipError_t = hipError_t(215);
}
impl hipError_t {
    pub const hipErrorContextAlreadyInUse: hipError_t = hipError_t(216);
}
impl hipError_t {
    pub const hipErrorPeerAccessUnsupported: hipError_t = hipError_t(217);
}
impl hipError_t {
    #[doc = "< In CUDA DRV, it is CUDA_ERROR_INVALID_PTX"]
    pub const hipErrorInvalidKernelFile: hipError_t = hipError_t(218);
}
impl hipError_t {
    pub const hipErrorInvalidGraphicsContext: hipError_t = hipError_t(219);
}
impl hipError_t {
    pub const hipErrorInvalidSource: hipError_t = hipError_t(300);
}
impl hipError_t {
    pub const hipErrorFileNotFound: hipError_t = hipError_t(301);
}
impl hipError_t {
    pub const hipErrorSharedObjectSymbolNotFound: hipError_t = hipError_t(302);
}
impl hipError_t {
    pub const hipErrorSharedObjectInitFailed: hipError_t = hipError_t(303);
}
impl hipError_t {
    pub const hipErrorOperatingSystem: hipError_t = hipError_t(304);
}
impl hipError_t {
    pub const hipErrorInvalidHandle: hipError_t = hipError_t(400);
}
impl hipError_t {
    #[doc = "< Resource handle (hipEvent_t or hipStream_t) invalid."]
    pub const hipErrorInvalidResourceHandle: hipError_t = hipError_t(400);
}
impl hipError_t {
    pub const hipErrorNotFound: hipError_t = hipError_t(500);
}
impl hipError_t {
    #[doc = "< Indicates that asynchronous operations enqueued earlier are not"]
    #[doc = "< ready.  This is not actually an error, but is used to distinguish"]
    #[doc = "< from hipSuccess (which indicates completion).  APIs that return"]
    #[doc = "< this error include hipEventQuery and hipStreamQuery."]
    pub const hipErrorNotReady: hipError_t = hipError_t(600);
}
impl hipError_t {
    pub const hipErrorIllegalAddress: hipError_t = hipError_t(700);
}
impl hipError_t {
    #[doc = "< Out of resources error."]
    pub const hipErrorLaunchOutOfResources: hipError_t = hipError_t(701);
}
impl hipError_t {
    pub const hipErrorLaunchTimeOut: hipError_t = hipError_t(702);
}
impl hipError_t {
    pub const hipErrorPeerAccessAlreadyEnabled: hipError_t = hipError_t(704);
}
impl hipError_t {
    pub const hipErrorPeerAccessNotEnabled: hipError_t = hipError_t(705);
}
impl hipError_t {
    pub const hipErrorSetOnActiveProcess: hipError_t = hipError_t(708);
}
impl hipError_t {
    pub const hipErrorContextIsDestroyed: hipError_t = hipError_t(709);
}
impl hipError_t {
    #[doc = "< Produced when the kernel calls assert."]
    pub const hipErrorAssert: hipError_t = hipError_t(710);
}
impl hipError_t {
    pub const hipErrorHostMemoryAlreadyRegistered: hipError_t = hipError_t(712);
}
impl hipError_t {
    pub const hipErrorHostMemoryNotRegistered: hipError_t = hipError_t(713);
}
impl hipError_t {
    pub const hipErrorLaunchFailure: hipError_t = hipError_t(719);
}
impl hipError_t {
    pub const hipErrorCooperativeLaunchTooLarge: hipError_t = hipError_t(720);
}
impl hipError_t {
    #[doc = "< Produced when the hip API is not supported/implemented"]
    pub const hipErrorNotSupported: hipError_t = hipError_t(801);
}
impl hipError_t {
    #[doc = "< The operation is not permitted when the stream"]
    #[doc = "< is capturing."]
    pub const hipErrorStreamCaptureUnsupported: hipError_t = hipError_t(900);
}
impl hipError_t {
    #[doc = "< The current capture sequence on the stream"]
    #[doc = "< has been invalidated due to a previous error."]
    pub const hipErrorStreamCaptureInvalidated: hipError_t = hipError_t(901);
}
impl hipError_t {
    #[doc = "< The operation would have resulted in a merge of"]
    #[doc = "< two independent capture sequences."]
    pub const hipErrorStreamCaptureMerge: hipError_t = hipError_t(902);
}
impl hipError_t {
    #[doc = "< The capture was not initiated in this stream."]
    pub const hipErrorStreamCaptureUnmatched: hipError_t = hipError_t(903);
}
impl hipError_t {
    #[doc = "< The capture sequence contains a fork that was not"]
    #[doc = "< joined to the primary stream."]
    pub const hipErrorStreamCaptureUnjoined: hipError_t = hipError_t(904);
}
impl hipError_t {
    #[doc = "< A dependency would have been created which crosses"]
    #[doc = "< the capture sequence boundary. Only implicit"]
    #[doc = "< in-stream ordering dependencies  are allowed"]
    #[doc = "< to cross the boundary"]
    pub const hipErrorStreamCaptureIsolation: hipError_t = hipError_t(905);
}
impl hipError_t {
    #[doc = "< The operation would have resulted in a disallowed"]
    #[doc = "< implicit dependency on a current capture sequence"]
    #[doc = "< from hipStreamLegacy."]
    pub const hipErrorStreamCaptureImplicit: hipError_t = hipError_t(906);
}
impl hipError_t {
    #[doc = "< The operation is not permitted on an event which was last"]
    #[doc = "< recorded in a capturing stream."]
    pub const hipErrorCapturedEvent: hipError_t = hipError_t(907);
}
impl hipError_t {
    #[doc = "< A stream capture sequence not initiated with"]
    #[doc = "< the hipStreamCaptureModeRelaxed argument to"]
    #[doc = "< hipStreamBeginCapture was passed to"]
    #[doc = "< hipStreamEndCapture in a different thread."]
    pub const hipErrorStreamCaptureWrongThread: hipError_t = hipError_t(908);
}
impl hipError_t {
    pub const hipErrorUnknown: hipError_t = hipError_t(999);
}
impl hipError_t {
    #[doc = "< HSA runtime memory call returned error.  Typically not seen"]
    #[doc = "< in production systems."]
    pub const hipErrorRuntimeMemory: hipError_t = hipError_t(1052);
}
impl hipError_t {
    #[doc = "< HSA runtime call other than memory returned error.  Typically"]
    #[doc = "< not seen in production systems."]
    pub const hipErrorRuntimeOther: hipError_t = hipError_t(1053);
}
impl hipError_t {
    #[doc = "< Marker that more error codes are needed."]
    pub const hipErrorTbd: hipError_t = hipError_t(1054);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
#[must_use]
pub struct hipError_t(pub ::std::os::raw::c_uint);
impl hipDeviceAttribute_t {
    #[doc = "< Maximum number of threads per block."]
    pub const hipDeviceAttributeMaxThreadsPerBlock: hipDeviceAttribute_t = hipDeviceAttribute_t(0);
}
impl hipDeviceAttribute_t {
    #[doc = "< Maximum x-dimension of a block."]
    pub const hipDeviceAttributeMaxBlockDimX: hipDeviceAttribute_t = hipDeviceAttribute_t(1);
}
impl hipDeviceAttribute_t {
    #[doc = "< Maximum y-dimension of a block."]
    pub const hipDeviceAttributeMaxBlockDimY: hipDeviceAttribute_t = hipDeviceAttribute_t(2);
}
impl hipDeviceAttribute_t {
    #[doc = "< Maximum z-dimension of a block."]
    pub const hipDeviceAttributeMaxBlockDimZ: hipDeviceAttribute_t = hipDeviceAttribute_t(3);
}
impl hipDeviceAttribute_t {
    #[doc = "< Maximum x-dimension of a grid."]
    pub const hipDeviceAttributeMaxGridDimX: hipDeviceAttribute_t = hipDeviceAttribute_t(4);
}
impl hipDeviceAttribute_t {
    #[doc = "< Maximum y-dimension of a grid."]
    pub const hipDeviceAttributeMaxGridDimY: hipDeviceAttribute_t = hipDeviceAttribute_t(5);
}
impl hipDeviceAttribute_t {
    #[doc = "< Maximum z-dimension of a grid."]
    pub const hipDeviceAttributeMaxGridDimZ: hipDeviceAttribute_t = hipDeviceAttribute_t(6);
}
impl hipDeviceAttribute_t {
    #[doc = "< Maximum shared memory available per block in"]
    #[doc = "< bytes."]
    pub const hipDeviceAttributeMaxSharedMemoryPerBlock: hipDeviceAttribute_t =
        hipDeviceAttribute_t(7);
}
impl hipDeviceAttribute_t {
    #[doc = "< Constant memory size in bytes."]
    pub const hipDeviceAttributeTotalConstantMemory: hipDeviceAttribute_t = hipDeviceAttribute_t(8);
}
impl hipDeviceAttribute_t {
    #[doc = "< Warp size in threads."]
    pub const hipDeviceAttributeWarpSize: hipDeviceAttribute_t = hipDeviceAttribute_t(9);
}
impl hipDeviceAttribute_t {
    #[doc = "< Maximum number of 32-bit registers available to a"]
    #[doc = "< thread block. This number is shared by all thread"]
    #[doc = "< blocks simultaneously resident on a"]
    #[doc = "< multiprocessor."]
    pub const hipDeviceAttributeMaxRegistersPerBlock: hipDeviceAttribute_t =
        hipDeviceAttribute_t(10);
}
impl hipDeviceAttribute_t {
    #[doc = "< Peak clock frequency in kilohertz."]
    pub const hipDeviceAttributeClockRate: hipDeviceAttribute_t = hipDeviceAttribute_t(11);
}
impl hipDeviceAttribute_t {
    #[doc = "< Peak memory clock frequency in kilohertz."]
    pub const hipDeviceAttributeMemoryClockRate: hipDeviceAttribute_t = hipDeviceAttribute_t(12);
}
impl hipDeviceAttribute_t {
    #[doc = "< Global memory bus width in bits."]
    pub const hipDeviceAttributeMemoryBusWidth: hipDeviceAttribute_t = hipDeviceAttribute_t(13);
}
impl hipDeviceAttribute_t {
    #[doc = "< Number of multiprocessors on the device."]
    pub const hipDeviceAttributeMultiprocessorCount: hipDeviceAttribute_t =
        hipDeviceAttribute_t(14);
}
impl hipDeviceAttribute_t {
    #[doc = "< Compute mode that device is currently in."]
    pub const hipDeviceAttributeComputeMode: hipDeviceAttribute_t = hipDeviceAttribute_t(15);
}
impl hipDeviceAttribute_t {
    #[doc = "< Size of L2 cache in bytes. 0 if the device doesn't have L2"]
    #[doc = "< cache."]
    pub const hipDeviceAttributeL2CacheSize: hipDeviceAttribute_t = hipDeviceAttribute_t(16);
}
impl hipDeviceAttribute_t {
    #[doc = "< Maximum resident threads per"]
    #[doc = "< multiprocessor."]
    pub const hipDeviceAttributeMaxThreadsPerMultiProcessor: hipDeviceAttribute_t =
        hipDeviceAttribute_t(17);
}
impl hipDeviceAttribute_t {
    #[doc = "< Major compute capability version number."]
    pub const hipDeviceAttributeComputeCapabilityMajor: hipDeviceAttribute_t =
        hipDeviceAttribute_t(18);
}
impl hipDeviceAttribute_t {
    #[doc = "< Minor compute capability version number."]
    pub const hipDeviceAttributeComputeCapabilityMinor: hipDeviceAttribute_t =
        hipDeviceAttribute_t(19);
}
impl hipDeviceAttribute_t {
    #[doc = "< Device can possibly execute multiple kernels"]
    #[doc = "< concurrently."]
    pub const hipDeviceAttributeConcurrentKernels: hipDeviceAttribute_t = hipDeviceAttribute_t(20);
}
impl hipDeviceAttribute_t {
    #[doc = "< PCI Bus ID."]
    pub const hipDeviceAttributePciBusId: hipDeviceAttribute_t = hipDeviceAttribute_t(21);
}
impl hipDeviceAttribute_t {
    #[doc = "< PCI Device ID."]
    pub const hipDeviceAttributePciDeviceId: hipDeviceAttribute_t = hipDeviceAttribute_t(22);
}
impl hipDeviceAttribute_t {
    #[doc = "< Maximum Shared Memory Per"]
    #[doc = "< Multiprocessor."]
    pub const hipDeviceAttributeMaxSharedMemoryPerMultiprocessor: hipDeviceAttribute_t =
        hipDeviceAttribute_t(23);
}
impl hipDeviceAttribute_t {
    #[doc = "< Multiple GPU devices."]
    pub const hipDeviceAttributeIsMultiGpuBoard: hipDeviceAttribute_t = hipDeviceAttribute_t(24);
}
impl hipDeviceAttribute_t {
    #[doc = "< iGPU"]
    pub const hipDeviceAttributeIntegrated: hipDeviceAttribute_t = hipDeviceAttribute_t(25);
}
impl hipDeviceAttribute_t {
    #[doc = "< Support cooperative launch"]
    pub const hipDeviceAttributeCooperativeLaunch: hipDeviceAttribute_t = hipDeviceAttribute_t(26);
}
impl hipDeviceAttribute_t {
    #[doc = "< Support cooperative launch on multiple devices"]
    pub const hipDeviceAttributeCooperativeMultiDeviceLaunch: hipDeviceAttribute_t =
        hipDeviceAttribute_t(27);
}
impl hipDeviceAttribute_t {
    #[doc = "< Maximum number of elements in 1D images"]
    pub const hipDeviceAttributeMaxTexture1DWidth: hipDeviceAttribute_t = hipDeviceAttribute_t(28);
}
impl hipDeviceAttribute_t {
    #[doc = "< Maximum dimension width of 2D images in image elements"]
    pub const hipDeviceAttributeMaxTexture2DWidth: hipDeviceAttribute_t = hipDeviceAttribute_t(29);
}
impl hipDeviceAttribute_t {
    #[doc = "< Maximum dimension height of 2D images in image elements"]
    pub const hipDeviceAttributeMaxTexture2DHeight: hipDeviceAttribute_t = hipDeviceAttribute_t(30);
}
impl hipDeviceAttribute_t {
    #[doc = "< Maximum dimension width of 3D images in image elements"]
    pub const hipDeviceAttributeMaxTexture3DWidth: hipDeviceAttribute_t = hipDeviceAttribute_t(31);
}
impl hipDeviceAttribute_t {
    #[doc = "< Maximum dimensions height of 3D images in image elements"]
    pub const hipDeviceAttributeMaxTexture3DHeight: hipDeviceAttribute_t = hipDeviceAttribute_t(32);
}
impl hipDeviceAttribute_t {
    #[doc = "< Maximum dimensions depth of 3D images in image elements"]
    pub const hipDeviceAttributeMaxTexture3DDepth: hipDeviceAttribute_t = hipDeviceAttribute_t(33);
}
impl hipDeviceAttribute_t {
    #[doc = "< Address of the HDP_MEM_COHERENCY_FLUSH_CNTL register"]
    pub const hipDeviceAttributeHdpMemFlushCntl: hipDeviceAttribute_t = hipDeviceAttribute_t(34);
}
impl hipDeviceAttribute_t {
    #[doc = "< Address of the HDP_REG_COHERENCY_FLUSH_CNTL register"]
    pub const hipDeviceAttributeHdpRegFlushCntl: hipDeviceAttribute_t = hipDeviceAttribute_t(35);
}
impl hipDeviceAttribute_t {
    #[doc = "< Maximum pitch in bytes allowed by memory copies"]
    pub const hipDeviceAttributeMaxPitch: hipDeviceAttribute_t = hipDeviceAttribute_t(36);
}
impl hipDeviceAttribute_t {
    #[doc = "<Alignment requirement for textures"]
    pub const hipDeviceAttributeTextureAlignment: hipDeviceAttribute_t = hipDeviceAttribute_t(37);
}
impl hipDeviceAttribute_t {
    #[doc = "<Pitch alignment requirement for 2D texture references bound to pitched memory;"]
    pub const hipDeviceAttributeTexturePitchAlignment: hipDeviceAttribute_t =
        hipDeviceAttribute_t(38);
}
impl hipDeviceAttribute_t {
    #[doc = "<Run time limit for kernels executed on the device"]
    pub const hipDeviceAttributeKernelExecTimeout: hipDeviceAttribute_t = hipDeviceAttribute_t(39);
}
impl hipDeviceAttribute_t {
    #[doc = "<Device can map host memory into device address space"]
    pub const hipDeviceAttributeCanMapHostMemory: hipDeviceAttribute_t = hipDeviceAttribute_t(40);
}
impl hipDeviceAttribute_t {
    #[doc = "<Device has ECC support enabled"]
    pub const hipDeviceAttributeEccEnabled: hipDeviceAttribute_t = hipDeviceAttribute_t(41);
}
impl hipDeviceAttribute_t {
    #[doc = "< Supports cooperative launch on multiple"]
    pub const hipDeviceAttributeCooperativeMultiDeviceUnmatchedFunc: hipDeviceAttribute_t =
        hipDeviceAttribute_t(42);
}
impl hipDeviceAttribute_t {
    #[doc = "< Supports cooperative launch on multiple"]
    pub const hipDeviceAttributeCooperativeMultiDeviceUnmatchedGridDim: hipDeviceAttribute_t =
        hipDeviceAttribute_t(43);
}
impl hipDeviceAttribute_t {
    #[doc = "< Supports cooperative launch on multiple"]
    pub const hipDeviceAttributeCooperativeMultiDeviceUnmatchedBlockDim: hipDeviceAttribute_t =
        hipDeviceAttribute_t(44);
}
impl hipDeviceAttribute_t {
    #[doc = "< Supports cooperative launch on multiple"]
    pub const hipDeviceAttributeCooperativeMultiDeviceUnmatchedSharedMem: hipDeviceAttribute_t =
        hipDeviceAttribute_t(45);
}
impl hipDeviceAttribute_t {
    #[doc = "< Revision of the GPU in this device"]
    pub const hipDeviceAttributeAsicRevision: hipDeviceAttribute_t = hipDeviceAttribute_t(46);
}
impl hipDeviceAttribute_t {
    #[doc = "< Device supports allocating managed memory on this system"]
    pub const hipDeviceAttributeManagedMemory: hipDeviceAttribute_t = hipDeviceAttribute_t(47);
}
impl hipDeviceAttribute_t {
    #[doc = "< Host can directly access managed memory on"]
    pub const hipDeviceAttributeDirectManagedMemAccessFromHost: hipDeviceAttribute_t =
        hipDeviceAttribute_t(48);
}
impl hipDeviceAttribute_t {
    #[doc = "< Device can coherently access managed memory"]
    pub const hipDeviceAttributeConcurrentManagedAccess: hipDeviceAttribute_t =
        hipDeviceAttribute_t(49);
}
impl hipDeviceAttribute_t {
    #[doc = "< Device supports coherently accessing pageable memory"]
    pub const hipDeviceAttributePageableMemoryAccess: hipDeviceAttribute_t =
        hipDeviceAttribute_t(50);
}
impl hipDeviceAttribute_t {
    #[doc = "< Device accesses pageable memory via"]
    pub const hipDeviceAttributePageableMemoryAccessUsesHostPageTables: hipDeviceAttribute_t =
        hipDeviceAttribute_t(51);
}
impl hipDeviceAttribute_t {
    #[doc = "< '1' if Device supports hipStreamWaitValue32() and"]
    #[doc = "< hipStreamWaitValue64() , '0' otherwise."]
    pub const hipDeviceAttributeCanUseStreamWaitValue: hipDeviceAttribute_t =
        hipDeviceAttribute_t(52);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hipDeviceAttribute_t(pub ::std::os::raw::c_uint);
impl hipComputeMode {
    pub const hipComputeModeDefault: hipComputeMode = hipComputeMode(0);
}
impl hipComputeMode {
    pub const hipComputeModeExclusive: hipComputeMode = hipComputeMode(1);
}
impl hipComputeMode {
    pub const hipComputeModeProhibited: hipComputeMode = hipComputeMode(2);
}
impl hipComputeMode {
    pub const hipComputeModeExclusiveProcess: hipComputeMode = hipComputeMode(3);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hipComputeMode(pub ::std::os::raw::c_uint);
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type hipDeviceptr_t = *mut ::std::os::raw::c_void;
impl hipChannelFormatKind {
    pub const hipChannelFormatKindSigned: hipChannelFormatKind = hipChannelFormatKind(0);
}
impl hipChannelFormatKind {
    pub const hipChannelFormatKindUnsigned: hipChannelFormatKind = hipChannelFormatKind(1);
}
impl hipChannelFormatKind {
    pub const hipChannelFormatKindFloat: hipChannelFormatKind = hipChannelFormatKind(2);
}
impl hipChannelFormatKind {
    pub const hipChannelFormatKindNone: hipChannelFormatKind = hipChannelFormatKind(3);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hipChannelFormatKind(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipChannelFormatDesc {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub z: ::std::os::raw::c_int,
    pub w: ::std::os::raw::c_int,
    pub f: hipChannelFormatKind,
}
impl hipArray_Format {
    pub const HIP_AD_FORMAT_UNSIGNED_INT8: hipArray_Format = hipArray_Format(1);
}
impl hipArray_Format {
    pub const HIP_AD_FORMAT_UNSIGNED_INT16: hipArray_Format = hipArray_Format(2);
}
impl hipArray_Format {
    pub const HIP_AD_FORMAT_UNSIGNED_INT32: hipArray_Format = hipArray_Format(3);
}
impl hipArray_Format {
    pub const HIP_AD_FORMAT_SIGNED_INT8: hipArray_Format = hipArray_Format(8);
}
impl hipArray_Format {
    pub const HIP_AD_FORMAT_SIGNED_INT16: hipArray_Format = hipArray_Format(9);
}
impl hipArray_Format {
    pub const HIP_AD_FORMAT_SIGNED_INT32: hipArray_Format = hipArray_Format(10);
}
impl hipArray_Format {
    pub const HIP_AD_FORMAT_HALF: hipArray_Format = hipArray_Format(16);
}
impl hipArray_Format {
    pub const HIP_AD_FORMAT_FLOAT: hipArray_Format = hipArray_Format(32);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hipArray_Format(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_ARRAY_DESCRIPTOR {
    pub Width: usize,
    pub Height: usize,
    pub Format: hipArray_Format,
    pub NumChannels: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_ARRAY3D_DESCRIPTOR {
    pub Width: usize,
    pub Height: usize,
    pub Depth: usize,
    pub Format: hipArray_Format,
    pub NumChannels: ::std::os::raw::c_uint,
    pub Flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipArray {
    pub data: *mut ::std::os::raw::c_void,
    pub desc: hipChannelFormatDesc,
    pub type_: ::std::os::raw::c_uint,
    pub width: ::std::os::raw::c_uint,
    pub height: ::std::os::raw::c_uint,
    pub depth: ::std::os::raw::c_uint,
    pub Format: hipArray_Format,
    pub NumChannels: ::std::os::raw::c_uint,
    pub isDrv: bool,
    pub textureType: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hip_Memcpy2D {
    pub srcXInBytes: usize,
    pub srcY: usize,
    pub srcMemoryType: hipMemoryType,
    pub srcHost: *const ::std::os::raw::c_void,
    pub srcDevice: hipDeviceptr_t,
    pub srcArray: *mut hipArray,
    pub srcPitch: usize,
    pub dstXInBytes: usize,
    pub dstY: usize,
    pub dstMemoryType: hipMemoryType,
    pub dstHost: *mut ::std::os::raw::c_void,
    pub dstDevice: hipDeviceptr_t,
    pub dstArray: *mut hipArray,
    pub dstPitch: usize,
    pub WidthInBytes: usize,
    pub Height: usize,
}
pub type hipArray_t = *mut hipArray;
pub type hiparray = hipArray_t;
pub type hipArray_const_t = *const hipArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipMipmappedArray {
    pub data: *mut ::std::os::raw::c_void,
    pub desc: hipChannelFormatDesc,
    pub type_: ::std::os::raw::c_uint,
    pub width: ::std::os::raw::c_uint,
    pub height: ::std::os::raw::c_uint,
    pub depth: ::std::os::raw::c_uint,
    pub min_mipmap_level: ::std::os::raw::c_uint,
    pub max_mipmap_level: ::std::os::raw::c_uint,
    pub flags: ::std::os::raw::c_uint,
    pub format: hipArray_Format,
}
pub type hipMipmappedArray_t = *mut hipMipmappedArray;
pub type hipMipmappedArray_const_t = *const hipMipmappedArray;
impl hipResourceType {
    pub const hipResourceTypeArray: hipResourceType = hipResourceType(0);
}
impl hipResourceType {
    pub const hipResourceTypeMipmappedArray: hipResourceType = hipResourceType(1);
}
impl hipResourceType {
    pub const hipResourceTypeLinear: hipResourceType = hipResourceType(2);
}
impl hipResourceType {
    pub const hipResourceTypePitch2D: hipResourceType = hipResourceType(3);
}
#[repr(transparent)]
#[doc = " hip resource types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hipResourceType(pub ::std::os::raw::c_uint);
impl HIPresourcetype_enum {
    #[doc = "< Array resoure"]
    pub const HIP_RESOURCE_TYPE_ARRAY: HIPresourcetype_enum = HIPresourcetype_enum(0);
}
impl HIPresourcetype_enum {
    #[doc = "< Mipmapped array resource"]
    pub const HIP_RESOURCE_TYPE_MIPMAPPED_ARRAY: HIPresourcetype_enum = HIPresourcetype_enum(1);
}
impl HIPresourcetype_enum {
    #[doc = "< Linear resource"]
    pub const HIP_RESOURCE_TYPE_LINEAR: HIPresourcetype_enum = HIPresourcetype_enum(2);
}
impl HIPresourcetype_enum {
    #[doc = "< Pitch 2D resource"]
    pub const HIP_RESOURCE_TYPE_PITCH2D: HIPresourcetype_enum = HIPresourcetype_enum(3);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct HIPresourcetype_enum(pub ::std::os::raw::c_uint);
pub use self::HIPresourcetype_enum as HIPresourcetype;
impl HIPaddress_mode_enum {
    pub const HIP_TR_ADDRESS_MODE_WRAP: HIPaddress_mode_enum = HIPaddress_mode_enum(0);
}
impl HIPaddress_mode_enum {
    pub const HIP_TR_ADDRESS_MODE_CLAMP: HIPaddress_mode_enum = HIPaddress_mode_enum(1);
}
impl HIPaddress_mode_enum {
    pub const HIP_TR_ADDRESS_MODE_MIRROR: HIPaddress_mode_enum = HIPaddress_mode_enum(2);
}
impl HIPaddress_mode_enum {
    pub const HIP_TR_ADDRESS_MODE_BORDER: HIPaddress_mode_enum = HIPaddress_mode_enum(3);
}
#[repr(transparent)]
#[doc = " hip address modes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct HIPaddress_mode_enum(pub ::std::os::raw::c_uint);
#[doc = " hip address modes"]
pub use self::HIPaddress_mode_enum as HIPaddress_mode;
impl HIPfilter_mode_enum {
    pub const HIP_TR_FILTER_MODE_POINT: HIPfilter_mode_enum = HIPfilter_mode_enum(0);
}
impl HIPfilter_mode_enum {
    pub const HIP_TR_FILTER_MODE_LINEAR: HIPfilter_mode_enum = HIPfilter_mode_enum(1);
}
#[repr(transparent)]
#[doc = " hip filter modes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct HIPfilter_mode_enum(pub ::std::os::raw::c_uint);
#[doc = " hip filter modes"]
pub use self::HIPfilter_mode_enum as HIPfilter_mode;
#[doc = " Texture descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_TEXTURE_DESC_st {
    #[doc = "< Address modes"]
    pub addressMode: [HIPaddress_mode; 3usize],
    #[doc = "< Filter mode"]
    pub filterMode: HIPfilter_mode,
    #[doc = "< Flags"]
    pub flags: ::std::os::raw::c_uint,
    #[doc = "< Maximum anisotropy ratio"]
    pub maxAnisotropy: ::std::os::raw::c_uint,
    #[doc = "< Mipmap filter mode"]
    pub mipmapFilterMode: HIPfilter_mode,
    #[doc = "< Mipmap level bias"]
    pub mipmapLevelBias: f32,
    #[doc = "< Mipmap minimum level clamp"]
    pub minMipmapLevelClamp: f32,
    #[doc = "< Mipmap maximum level clamp"]
    pub maxMipmapLevelClamp: f32,
    #[doc = "< Border Color"]
    pub borderColor: [f32; 4usize],
    pub reserved: [::std::os::raw::c_int; 12usize],
}
#[doc = " Texture descriptor"]
pub type HIP_TEXTURE_DESC = HIP_TEXTURE_DESC_st;
impl hipResourceViewFormat {
    pub const hipResViewFormatNone: hipResourceViewFormat = hipResourceViewFormat(0);
}
impl hipResourceViewFormat {
    pub const hipResViewFormatUnsignedChar1: hipResourceViewFormat = hipResourceViewFormat(1);
}
impl hipResourceViewFormat {
    pub const hipResViewFormatUnsignedChar2: hipResourceViewFormat = hipResourceViewFormat(2);
}
impl hipResourceViewFormat {
    pub const hipResViewFormatUnsignedChar4: hipResourceViewFormat = hipResourceViewFormat(3);
}
impl hipResourceViewFormat {
    pub const hipResViewFormatSignedChar1: hipResourceViewFormat = hipResourceViewFormat(4);
}
impl hipResourceViewFormat {
    pub const hipResViewFormatSignedChar2: hipResourceViewFormat = hipResourceViewFormat(5);
}
impl hipResourceViewFormat {
    pub const hipResViewFormatSignedChar4: hipResourceViewFormat = hipResourceViewFormat(6);
}
impl hipResourceViewFormat {
    pub const hipResViewFormatUnsignedShort1: hipResourceViewFormat = hipResourceViewFormat(7);
}
impl hipResourceViewFormat {
    pub const hipResViewFormatUnsignedShort2: hipResourceViewFormat = hipResourceViewFormat(8);
}
impl hipResourceViewFormat {
    pub const hipResViewFormatUnsignedShort4: hipResourceViewFormat = hipResourceViewFormat(9);
}
impl hipResourceViewFormat {
    pub const hipResViewFormatSignedShort1: hipResourceViewFormat = hipResourceViewFormat(10);
}
impl hipResourceViewFormat {
    pub const hipResViewFormatSignedShort2: hipResourceViewFormat = hipResourceViewFormat(11);
}
impl hipResourceViewFormat {
    pub const hipResViewFormatSignedShort4: hipResourceViewFormat = hipResourceViewFormat(12);
}
impl hipResourceViewFormat {
    pub const hipResViewFormatUnsignedInt1: hipResourceViewFormat = hipResourceViewFormat(13);
}
impl hipResourceViewFormat {
    pub const hipResViewFormatUnsignedInt2: hipResourceViewFormat = hipResourceViewFormat(14);
}
impl hipResourceViewFormat {
    pub const hipResViewFormatUnsignedInt4: hipResourceViewFormat = hipResourceViewFormat(15);
}
impl hipResourceViewFormat {
    pub const hipResViewFormatSignedInt1: hipResourceViewFormat = hipResourceViewFormat(16);
}
impl hipResourceViewFormat {
    pub const hipResViewFormatSignedInt2: hipResourceViewFormat = hipResourceViewFormat(17);
}
impl hipResourceViewFormat {
    pub const hipResViewFormatSignedInt4: hipResourceViewFormat = hipResourceViewFormat(18);
}
impl hipResourceViewFormat {
    pub const hipResViewFormatHalf1: hipResourceViewFormat = hipResourceViewFormat(19);
}
impl hipResourceViewFormat {
    pub const hipResViewFormatHalf2: hipResourceViewFormat = hipResourceViewFormat(20);
}
impl hipResourceViewFormat {
    pub const hipResViewFormatHalf4: hipResourceViewFormat = hipResourceViewFormat(21);
}
impl hipResourceViewFormat {
    pub const hipResViewFormatFloat1: hipResourceViewFormat = hipResourceViewFormat(22);
}
impl hipResourceViewFormat {
    pub const hipResViewFormatFloat2: hipResourceViewFormat = hipResourceViewFormat(23);
}
impl hipResourceViewFormat {
    pub const hipResViewFormatFloat4: hipResourceViewFormat = hipResourceViewFormat(24);
}
impl hipResourceViewFormat {
    pub const hipResViewFormatUnsignedBlockCompressed1: hipResourceViewFormat =
        hipResourceViewFormat(25);
}
impl hipResourceViewFormat {
    pub const hipResViewFormatUnsignedBlockCompressed2: hipResourceViewFormat =
        hipResourceViewFormat(26);
}
impl hipResourceViewFormat {
    pub const hipResViewFormatUnsignedBlockCompressed3: hipResourceViewFormat =
        hipResourceViewFormat(27);
}
impl hipResourceViewFormat {
    pub const hipResViewFormatUnsignedBlockCompressed4: hipResourceViewFormat =
        hipResourceViewFormat(28);
}
impl hipResourceViewFormat {
    pub const hipResViewFormatSignedBlockCompressed4: hipResourceViewFormat =
        hipResourceViewFormat(29);
}
impl hipResourceViewFormat {
    pub const hipResViewFormatUnsignedBlockCompressed5: hipResourceViewFormat =
        hipResourceViewFormat(30);
}
impl hipResourceViewFormat {
    pub const hipResViewFormatSignedBlockCompressed5: hipResourceViewFormat =
        hipResourceViewFormat(31);
}
impl hipResourceViewFormat {
    pub const hipResViewFormatUnsignedBlockCompressed6H: hipResourceViewFormat =
        hipResourceViewFormat(32);
}
impl hipResourceViewFormat {
    pub const hipResViewFormatSignedBlockCompressed6H: hipResourceViewFormat =
        hipResourceViewFormat(33);
}
impl hipResourceViewFormat {
    pub const hipResViewFormatUnsignedBlockCompressed7: hipResourceViewFormat =
        hipResourceViewFormat(34);
}
#[repr(transparent)]
#[doc = " hip texture resource view formats"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hipResourceViewFormat(pub ::std::os::raw::c_uint);
impl HIPresourceViewFormat_enum {
    #[doc = "< No resource view format (use underlying resource format)"]
    pub const HIP_RES_VIEW_FORMAT_NONE: HIPresourceViewFormat_enum = HIPresourceViewFormat_enum(0);
}
impl HIPresourceViewFormat_enum {
    #[doc = "< 1 channel unsigned 8-bit integers"]
    pub const HIP_RES_VIEW_FORMAT_UINT_1X8: HIPresourceViewFormat_enum =
        HIPresourceViewFormat_enum(1);
}
impl HIPresourceViewFormat_enum {
    #[doc = "< 2 channel unsigned 8-bit integers"]
    pub const HIP_RES_VIEW_FORMAT_UINT_2X8: HIPresourceViewFormat_enum =
        HIPresourceViewFormat_enum(2);
}
impl HIPresourceViewFormat_enum {
    #[doc = "< 4 channel unsigned 8-bit integers"]
    pub const HIP_RES_VIEW_FORMAT_UINT_4X8: HIPresourceViewFormat_enum =
        HIPresourceViewFormat_enum(3);
}
impl HIPresourceViewFormat_enum {
    #[doc = "< 1 channel signed 8-bit integers"]
    pub const HIP_RES_VIEW_FORMAT_SINT_1X8: HIPresourceViewFormat_enum =
        HIPresourceViewFormat_enum(4);
}
impl HIPresourceViewFormat_enum {
    #[doc = "< 2 channel signed 8-bit integers"]
    pub const HIP_RES_VIEW_FORMAT_SINT_2X8: HIPresourceViewFormat_enum =
        HIPresourceViewFormat_enum(5);
}
impl HIPresourceViewFormat_enum {
    #[doc = "< 4 channel signed 8-bit integers"]
    pub const HIP_RES_VIEW_FORMAT_SINT_4X8: HIPresourceViewFormat_enum =
        HIPresourceViewFormat_enum(6);
}
impl HIPresourceViewFormat_enum {
    #[doc = "< 1 channel unsigned 16-bit integers"]
    pub const HIP_RES_VIEW_FORMAT_UINT_1X16: HIPresourceViewFormat_enum =
        HIPresourceViewFormat_enum(7);
}
impl HIPresourceViewFormat_enum {
    #[doc = "< 2 channel unsigned 16-bit integers"]
    pub const HIP_RES_VIEW_FORMAT_UINT_2X16: HIPresourceViewFormat_enum =
        HIPresourceViewFormat_enum(8);
}
impl HIPresourceViewFormat_enum {
    #[doc = "< 4 channel unsigned 16-bit integers"]
    pub const HIP_RES_VIEW_FORMAT_UINT_4X16: HIPresourceViewFormat_enum =
        HIPresourceViewFormat_enum(9);
}
impl HIPresourceViewFormat_enum {
    #[doc = "< 1 channel signed 16-bit integers"]
    pub const HIP_RES_VIEW_FORMAT_SINT_1X16: HIPresourceViewFormat_enum =
        HIPresourceViewFormat_enum(10);
}
impl HIPresourceViewFormat_enum {
    #[doc = "< 2 channel signed 16-bit integers"]
    pub const HIP_RES_VIEW_FORMAT_SINT_2X16: HIPresourceViewFormat_enum =
        HIPresourceViewFormat_enum(11);
}
impl HIPresourceViewFormat_enum {
    #[doc = "< 4 channel signed 16-bit integers"]
    pub const HIP_RES_VIEW_FORMAT_SINT_4X16: HIPresourceViewFormat_enum =
        HIPresourceViewFormat_enum(12);
}
impl HIPresourceViewFormat_enum {
    #[doc = "< 1 channel unsigned 32-bit integers"]
    pub const HIP_RES_VIEW_FORMAT_UINT_1X32: HIPresourceViewFormat_enum =
        HIPresourceViewFormat_enum(13);
}
impl HIPresourceViewFormat_enum {
    #[doc = "< 2 channel unsigned 32-bit integers"]
    pub const HIP_RES_VIEW_FORMAT_UINT_2X32: HIPresourceViewFormat_enum =
        HIPresourceViewFormat_enum(14);
}
impl HIPresourceViewFormat_enum {
    #[doc = "< 4 channel unsigned 32-bit integers"]
    pub const HIP_RES_VIEW_FORMAT_UINT_4X32: HIPresourceViewFormat_enum =
        HIPresourceViewFormat_enum(15);
}
impl HIPresourceViewFormat_enum {
    #[doc = "< 1 channel signed 32-bit integers"]
    pub const HIP_RES_VIEW_FORMAT_SINT_1X32: HIPresourceViewFormat_enum =
        HIPresourceViewFormat_enum(16);
}
impl HIPresourceViewFormat_enum {
    #[doc = "< 2 channel signed 32-bit integers"]
    pub const HIP_RES_VIEW_FORMAT_SINT_2X32: HIPresourceViewFormat_enum =
        HIPresourceViewFormat_enum(17);
}
impl HIPresourceViewFormat_enum {
    #[doc = "< 4 channel signed 32-bit integers"]
    pub const HIP_RES_VIEW_FORMAT_SINT_4X32: HIPresourceViewFormat_enum =
        HIPresourceViewFormat_enum(18);
}
impl HIPresourceViewFormat_enum {
    #[doc = "< 1 channel 16-bit floating point"]
    pub const HIP_RES_VIEW_FORMAT_FLOAT_1X16: HIPresourceViewFormat_enum =
        HIPresourceViewFormat_enum(19);
}
impl HIPresourceViewFormat_enum {
    #[doc = "< 2 channel 16-bit floating point"]
    pub const HIP_RES_VIEW_FORMAT_FLOAT_2X16: HIPresourceViewFormat_enum =
        HIPresourceViewFormat_enum(20);
}
impl HIPresourceViewFormat_enum {
    #[doc = "< 4 channel 16-bit floating point"]
    pub const HIP_RES_VIEW_FORMAT_FLOAT_4X16: HIPresourceViewFormat_enum =
        HIPresourceViewFormat_enum(21);
}
impl HIPresourceViewFormat_enum {
    #[doc = "< 1 channel 32-bit floating point"]
    pub const HIP_RES_VIEW_FORMAT_FLOAT_1X32: HIPresourceViewFormat_enum =
        HIPresourceViewFormat_enum(22);
}
impl HIPresourceViewFormat_enum {
    #[doc = "< 2 channel 32-bit floating point"]
    pub const HIP_RES_VIEW_FORMAT_FLOAT_2X32: HIPresourceViewFormat_enum =
        HIPresourceViewFormat_enum(23);
}
impl HIPresourceViewFormat_enum {
    #[doc = "< 4 channel 32-bit floating point"]
    pub const HIP_RES_VIEW_FORMAT_FLOAT_4X32: HIPresourceViewFormat_enum =
        HIPresourceViewFormat_enum(24);
}
impl HIPresourceViewFormat_enum {
    #[doc = "< Block compressed 1"]
    pub const HIP_RES_VIEW_FORMAT_UNSIGNED_BC1: HIPresourceViewFormat_enum =
        HIPresourceViewFormat_enum(25);
}
impl HIPresourceViewFormat_enum {
    #[doc = "< Block compressed 2"]
    pub const HIP_RES_VIEW_FORMAT_UNSIGNED_BC2: HIPresourceViewFormat_enum =
        HIPresourceViewFormat_enum(26);
}
impl HIPresourceViewFormat_enum {
    #[doc = "< Block compressed 3"]
    pub const HIP_RES_VIEW_FORMAT_UNSIGNED_BC3: HIPresourceViewFormat_enum =
        HIPresourceViewFormat_enum(27);
}
impl HIPresourceViewFormat_enum {
    #[doc = "< Block compressed 4 unsigned"]
    pub const HIP_RES_VIEW_FORMAT_UNSIGNED_BC4: HIPresourceViewFormat_enum =
        HIPresourceViewFormat_enum(28);
}
impl HIPresourceViewFormat_enum {
    #[doc = "< Block compressed 4 signed"]
    pub const HIP_RES_VIEW_FORMAT_SIGNED_BC4: HIPresourceViewFormat_enum =
        HIPresourceViewFormat_enum(29);
}
impl HIPresourceViewFormat_enum {
    #[doc = "< Block compressed 5 unsigned"]
    pub const HIP_RES_VIEW_FORMAT_UNSIGNED_BC5: HIPresourceViewFormat_enum =
        HIPresourceViewFormat_enum(30);
}
impl HIPresourceViewFormat_enum {
    #[doc = "< Block compressed 5 signed"]
    pub const HIP_RES_VIEW_FORMAT_SIGNED_BC5: HIPresourceViewFormat_enum =
        HIPresourceViewFormat_enum(31);
}
impl HIPresourceViewFormat_enum {
    #[doc = "< Block compressed 6 unsigned half-float"]
    pub const HIP_RES_VIEW_FORMAT_UNSIGNED_BC6H: HIPresourceViewFormat_enum =
        HIPresourceViewFormat_enum(32);
}
impl HIPresourceViewFormat_enum {
    #[doc = "< Block compressed 6 signed half-float"]
    pub const HIP_RES_VIEW_FORMAT_SIGNED_BC6H: HIPresourceViewFormat_enum =
        HIPresourceViewFormat_enum(33);
}
impl HIPresourceViewFormat_enum {
    #[doc = "< Block compressed 7"]
    pub const HIP_RES_VIEW_FORMAT_UNSIGNED_BC7: HIPresourceViewFormat_enum =
        HIPresourceViewFormat_enum(34);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct HIPresourceViewFormat_enum(pub ::std::os::raw::c_uint);
pub use self::HIPresourceViewFormat_enum as HIPresourceViewFormat;
#[doc = " HIP resource descriptor"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hipResourceDesc {
    pub resType: hipResourceType,
    pub res: hipResourceDesc__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hipResourceDesc__bindgen_ty_1 {
    pub array: hipResourceDesc__bindgen_ty_1__bindgen_ty_1,
    pub mipmap: hipResourceDesc__bindgen_ty_1__bindgen_ty_2,
    pub linear: hipResourceDesc__bindgen_ty_1__bindgen_ty_3,
    pub pitch2D: hipResourceDesc__bindgen_ty_1__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipResourceDesc__bindgen_ty_1__bindgen_ty_1 {
    pub array: hipArray_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipResourceDesc__bindgen_ty_1__bindgen_ty_2 {
    pub mipmap: hipMipmappedArray_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipResourceDesc__bindgen_ty_1__bindgen_ty_3 {
    pub devPtr: *mut ::std::os::raw::c_void,
    pub desc: hipChannelFormatDesc,
    pub sizeInBytes: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipResourceDesc__bindgen_ty_1__bindgen_ty_4 {
    pub devPtr: *mut ::std::os::raw::c_void,
    pub desc: hipChannelFormatDesc,
    pub width: usize,
    pub height: usize,
    pub pitchInBytes: usize,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct HIP_RESOURCE_DESC_st {
    #[doc = "< Resource type"]
    pub resType: HIPresourcetype,
    pub res: HIP_RESOURCE_DESC_st__bindgen_ty_1,
    #[doc = "< Flags (must be zero)"]
    pub flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union HIP_RESOURCE_DESC_st__bindgen_ty_1 {
    pub array: HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1,
    pub mipmap: HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2,
    pub linear: HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3,
    pub pitch2D: HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4,
    pub reserved: HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< HIP array"]
    pub hArray: hipArray_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "< HIP mipmapped array"]
    pub hMipmappedArray: hipMipmappedArray_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3 {
    #[doc = "< Device pointer"]
    pub devPtr: hipDeviceptr_t,
    #[doc = "< Array format"]
    pub format: hipArray_Format,
    #[doc = "< Channels per array element"]
    pub numChannels: ::std::os::raw::c_uint,
    #[doc = "< Size in bytes"]
    pub sizeInBytes: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4 {
    #[doc = "< Device pointer"]
    pub devPtr: hipDeviceptr_t,
    #[doc = "< Array format"]
    pub format: hipArray_Format,
    #[doc = "< Channels per array element"]
    pub numChannels: ::std::os::raw::c_uint,
    #[doc = "< Width of the array in elements"]
    pub width: usize,
    #[doc = "< Height of the array in elements"]
    pub height: usize,
    #[doc = "< Pitch between two rows in bytes"]
    pub pitchInBytes: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5 {
    pub reserved: [::std::os::raw::c_int; 32usize],
}
pub type HIP_RESOURCE_DESC = HIP_RESOURCE_DESC_st;
#[doc = " hip resource view descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipResourceViewDesc {
    pub format: hipResourceViewFormat,
    pub width: usize,
    pub height: usize,
    pub depth: usize,
    pub firstMipmapLevel: ::std::os::raw::c_uint,
    pub lastMipmapLevel: ::std::os::raw::c_uint,
    pub firstLayer: ::std::os::raw::c_uint,
    pub lastLayer: ::std::os::raw::c_uint,
}
#[doc = " Resource view descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_RESOURCE_VIEW_DESC_st {
    #[doc = "< Resource view format"]
    pub format: HIPresourceViewFormat,
    #[doc = "< Width of the resource view"]
    pub width: usize,
    #[doc = "< Height of the resource view"]
    pub height: usize,
    #[doc = "< Depth of the resource view"]
    pub depth: usize,
    #[doc = "< First defined mipmap level"]
    pub firstMipmapLevel: ::std::os::raw::c_uint,
    #[doc = "< Last defined mipmap level"]
    pub lastMipmapLevel: ::std::os::raw::c_uint,
    #[doc = "< First layer index"]
    pub firstLayer: ::std::os::raw::c_uint,
    #[doc = "< Last layer index"]
    pub lastLayer: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[doc = " Resource view descriptor"]
pub type HIP_RESOURCE_VIEW_DESC = HIP_RESOURCE_VIEW_DESC_st;
impl hipMemcpyKind {
    #[doc = "< Host-to-Host Copy"]
    pub const hipMemcpyHostToHost: hipMemcpyKind = hipMemcpyKind(0);
}
impl hipMemcpyKind {
    #[doc = "< Host-to-Device Copy"]
    pub const hipMemcpyHostToDevice: hipMemcpyKind = hipMemcpyKind(1);
}
impl hipMemcpyKind {
    #[doc = "< Device-to-Host Copy"]
    pub const hipMemcpyDeviceToHost: hipMemcpyKind = hipMemcpyKind(2);
}
impl hipMemcpyKind {
    #[doc = "< Device-to-Device Copy"]
    pub const hipMemcpyDeviceToDevice: hipMemcpyKind = hipMemcpyKind(3);
}
impl hipMemcpyKind {
    pub const hipMemcpyDefault: hipMemcpyKind = hipMemcpyKind(4);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hipMemcpyKind(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipPitchedPtr {
    pub ptr: *mut ::std::os::raw::c_void,
    pub pitch: usize,
    pub xsize: usize,
    pub ysize: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipExtent {
    pub width: usize,
    pub height: usize,
    pub depth: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipPos {
    pub x: usize,
    pub y: usize,
    pub z: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipMemcpy3DParms {
    pub srcArray: hipArray_t,
    pub srcPos: hipPos,
    pub srcPtr: hipPitchedPtr,
    pub dstArray: hipArray_t,
    pub dstPos: hipPos,
    pub dstPtr: hipPitchedPtr,
    pub extent: hipExtent,
    pub kind: hipMemcpyKind,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_MEMCPY3D {
    pub srcXInBytes: ::std::os::raw::c_uint,
    pub srcY: ::std::os::raw::c_uint,
    pub srcZ: ::std::os::raw::c_uint,
    pub srcLOD: ::std::os::raw::c_uint,
    pub srcMemoryType: hipMemoryType,
    pub srcHost: *const ::std::os::raw::c_void,
    pub srcDevice: hipDeviceptr_t,
    pub srcArray: hipArray_t,
    pub srcPitch: ::std::os::raw::c_uint,
    pub srcHeight: ::std::os::raw::c_uint,
    pub dstXInBytes: ::std::os::raw::c_uint,
    pub dstY: ::std::os::raw::c_uint,
    pub dstZ: ::std::os::raw::c_uint,
    pub dstLOD: ::std::os::raw::c_uint,
    pub dstMemoryType: hipMemoryType,
    pub dstHost: *mut ::std::os::raw::c_void,
    pub dstDevice: hipDeviceptr_t,
    pub dstArray: hipArray_t,
    pub dstPitch: ::std::os::raw::c_uint,
    pub dstHeight: ::std::os::raw::c_uint,
    pub WidthInBytes: ::std::os::raw::c_uint,
    pub Height: ::std::os::raw::c_uint,
    pub Depth: ::std::os::raw::c_uint,
}
impl hipFunction_attribute {
    pub const HIP_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK: hipFunction_attribute =
        hipFunction_attribute(0);
}
impl hipFunction_attribute {
    pub const HIP_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES: hipFunction_attribute =
        hipFunction_attribute(1);
}
impl hipFunction_attribute {
    pub const HIP_FUNC_ATTRIBUTE_CONST_SIZE_BYTES: hipFunction_attribute = hipFunction_attribute(2);
}
impl hipFunction_attribute {
    pub const HIP_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES: hipFunction_attribute = hipFunction_attribute(3);
}
impl hipFunction_attribute {
    pub const HIP_FUNC_ATTRIBUTE_NUM_REGS: hipFunction_attribute = hipFunction_attribute(4);
}
impl hipFunction_attribute {
    pub const HIP_FUNC_ATTRIBUTE_PTX_VERSION: hipFunction_attribute = hipFunction_attribute(5);
}
impl hipFunction_attribute {
    pub const HIP_FUNC_ATTRIBUTE_BINARY_VERSION: hipFunction_attribute = hipFunction_attribute(6);
}
impl hipFunction_attribute {
    pub const HIP_FUNC_ATTRIBUTE_CACHE_MODE_CA: hipFunction_attribute = hipFunction_attribute(7);
}
impl hipFunction_attribute {
    pub const HIP_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES: hipFunction_attribute =
        hipFunction_attribute(8);
}
impl hipFunction_attribute {
    pub const HIP_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT: hipFunction_attribute =
        hipFunction_attribute(9);
}
impl hipFunction_attribute {
    pub const HIP_FUNC_ATTRIBUTE_MAX: hipFunction_attribute = hipFunction_attribute(10);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hipFunction_attribute(pub ::std::os::raw::c_uint);
extern "C" {
    pub fn hipCreateChannelDesc(
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        z: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        f: hipChannelFormatKind,
    ) -> hipChannelFormatDesc;
}
#[doc = " An opaque value that represents a hip texture object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __hip_texture {
    _unused: [u8; 0],
}
pub type hipTextureObject_t = *mut __hip_texture;
impl hipTextureAddressMode {
    pub const hipAddressModeWrap: hipTextureAddressMode = hipTextureAddressMode(0);
}
impl hipTextureAddressMode {
    pub const hipAddressModeClamp: hipTextureAddressMode = hipTextureAddressMode(1);
}
impl hipTextureAddressMode {
    pub const hipAddressModeMirror: hipTextureAddressMode = hipTextureAddressMode(2);
}
impl hipTextureAddressMode {
    pub const hipAddressModeBorder: hipTextureAddressMode = hipTextureAddressMode(3);
}
#[repr(transparent)]
#[doc = " hip texture address modes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hipTextureAddressMode(pub ::std::os::raw::c_uint);
impl hipTextureFilterMode {
    pub const hipFilterModePoint: hipTextureFilterMode = hipTextureFilterMode(0);
}
impl hipTextureFilterMode {
    pub const hipFilterModeLinear: hipTextureFilterMode = hipTextureFilterMode(1);
}
#[repr(transparent)]
#[doc = " hip texture filter modes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hipTextureFilterMode(pub ::std::os::raw::c_uint);
impl hipTextureReadMode {
    pub const hipReadModeElementType: hipTextureReadMode = hipTextureReadMode(0);
}
impl hipTextureReadMode {
    pub const hipReadModeNormalizedFloat: hipTextureReadMode = hipTextureReadMode(1);
}
#[repr(transparent)]
#[doc = " hip texture read modes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hipTextureReadMode(pub ::std::os::raw::c_uint);
#[doc = " hip texture reference"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct textureReference {
    pub normalized: ::std::os::raw::c_int,
    pub readMode: hipTextureReadMode,
    pub filterMode: hipTextureFilterMode,
    pub addressMode: [hipTextureAddressMode; 3usize],
    pub channelDesc: hipChannelFormatDesc,
    pub sRGB: ::std::os::raw::c_int,
    pub maxAnisotropy: ::std::os::raw::c_uint,
    pub mipmapFilterMode: hipTextureFilterMode,
    pub mipmapLevelBias: f32,
    pub minMipmapLevelClamp: f32,
    pub maxMipmapLevelClamp: f32,
    pub textureObject: hipTextureObject_t,
    pub numChannels: ::std::os::raw::c_int,
    pub format: hipArray_Format,
}
#[doc = " hip texture descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipTextureDesc {
    pub addressMode: [hipTextureAddressMode; 3usize],
    pub filterMode: hipTextureFilterMode,
    pub readMode: hipTextureReadMode,
    pub sRGB: ::std::os::raw::c_int,
    pub borderColor: [f32; 4usize],
    pub normalizedCoords: ::std::os::raw::c_int,
    pub maxAnisotropy: ::std::os::raw::c_uint,
    pub mipmapFilterMode: hipTextureFilterMode,
    pub mipmapLevelBias: f32,
    pub minMipmapLevelClamp: f32,
    pub maxMipmapLevelClamp: f32,
}
#[doc = " An opaque value that represents a hip surface object"]
pub type hipSurfaceObject_t = ::std::os::raw::c_ulonglong;
impl hipSurfaceBoundaryMode {
    pub const hipBoundaryModeZero: hipSurfaceBoundaryMode = hipSurfaceBoundaryMode(0);
}
impl hipSurfaceBoundaryMode {
    pub const hipBoundaryModeTrap: hipSurfaceBoundaryMode = hipSurfaceBoundaryMode(1);
}
impl hipSurfaceBoundaryMode {
    pub const hipBoundaryModeClamp: hipSurfaceBoundaryMode = hipSurfaceBoundaryMode(2);
}
#[repr(transparent)]
#[doc = " hip surface boundary modes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hipSurfaceBoundaryMode(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipCtx_t {
    _unused: [u8; 0],
}
pub type hipCtx_t = *mut ihipCtx_t;
pub type hipDevice_t = ::std::os::raw::c_int;
impl hipDeviceP2PAttr {
    pub const hipDevP2PAttrPerformanceRank: hipDeviceP2PAttr = hipDeviceP2PAttr(0);
}
impl hipDeviceP2PAttr {
    pub const hipDevP2PAttrAccessSupported: hipDeviceP2PAttr = hipDeviceP2PAttr(1);
}
impl hipDeviceP2PAttr {
    pub const hipDevP2PAttrNativeAtomicSupported: hipDeviceP2PAttr = hipDeviceP2PAttr(2);
}
impl hipDeviceP2PAttr {
    pub const hipDevP2PAttrHipArrayAccessSupported: hipDeviceP2PAttr = hipDeviceP2PAttr(3);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hipDeviceP2PAttr(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipStream_t {
    _unused: [u8; 0],
}
pub type hipStream_t = *mut ihipStream_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipIpcMemHandle_st {
    pub reserved: [::std::os::raw::c_char; 64usize],
}
pub type hipIpcMemHandle_t = hipIpcMemHandle_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipIpcEventHandle_st {
    pub reserved: [::std::os::raw::c_char; 64usize],
}
pub type hipIpcEventHandle_t = hipIpcEventHandle_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipModule_t {
    _unused: [u8; 0],
}
pub type hipModule_t = *mut ihipModule_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipModuleSymbol_t {
    _unused: [u8; 0],
}
pub type hipFunction_t = *mut ihipModuleSymbol_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipFuncAttributes {
    pub binaryVersion: ::std::os::raw::c_int,
    pub cacheModeCA: ::std::os::raw::c_int,
    pub constSizeBytes: usize,
    pub localSizeBytes: usize,
    pub maxDynamicSharedSizeBytes: ::std::os::raw::c_int,
    pub maxThreadsPerBlock: ::std::os::raw::c_int,
    pub numRegs: ::std::os::raw::c_int,
    pub preferredShmemCarveout: ::std::os::raw::c_int,
    pub ptxVersion: ::std::os::raw::c_int,
    pub sharedSizeBytes: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipEvent_t {
    _unused: [u8; 0],
}
pub type hipEvent_t = *mut ihipEvent_t;
impl hipLimit_t {
    pub const hipLimitMallocHeapSize: hipLimit_t = hipLimit_t(2);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hipLimit_t(pub ::std::os::raw::c_uint);
impl hipMemoryAdvise {
    #[doc = "< Data will mostly be read and only occassionally"]
    #[doc = "< be written to"]
    pub const hipMemAdviseSetReadMostly: hipMemoryAdvise = hipMemoryAdvise(1);
}
impl hipMemoryAdvise {
    #[doc = "< Undo the effect of hipMemAdviseSetReadMostly"]
    pub const hipMemAdviseUnsetReadMostly: hipMemoryAdvise = hipMemoryAdvise(2);
}
impl hipMemoryAdvise {
    #[doc = "< Set the preferred location for the data as"]
    #[doc = "< the specified device"]
    pub const hipMemAdviseSetPreferredLocation: hipMemoryAdvise = hipMemoryAdvise(3);
}
impl hipMemoryAdvise {
    #[doc = "< Clear the preferred location for the data"]
    pub const hipMemAdviseUnsetPreferredLocation: hipMemoryAdvise = hipMemoryAdvise(4);
}
impl hipMemoryAdvise {
    #[doc = "< Data will be accessed by the specified device,"]
    #[doc = "< so prevent page faults as much as possible"]
    pub const hipMemAdviseSetAccessedBy: hipMemoryAdvise = hipMemoryAdvise(5);
}
impl hipMemoryAdvise {
    #[doc = "< Let the Unified Memory subsystem decide on"]
    #[doc = "< the page faulting policy for the specified device"]
    pub const hipMemAdviseUnsetAccessedBy: hipMemoryAdvise = hipMemoryAdvise(6);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hipMemoryAdvise(pub ::std::os::raw::c_uint);
impl hipMemRangeAttribute {
    #[doc = "< Whether the range will mostly be read and"]
    #[doc = "< only occassionally be written to"]
    pub const hipMemRangeAttributeReadMostly: hipMemRangeAttribute = hipMemRangeAttribute(1);
}
impl hipMemRangeAttribute {
    #[doc = "< The preferred location of the range"]
    pub const hipMemRangeAttributePreferredLocation: hipMemRangeAttribute = hipMemRangeAttribute(2);
}
impl hipMemRangeAttribute {
    #[doc = "< Memory range has cudaMemAdviseSetAccessedBy"]
    #[doc = "< set for specified device"]
    pub const hipMemRangeAttributeAccessedBy: hipMemRangeAttribute = hipMemRangeAttribute(3);
}
impl hipMemRangeAttribute {
    #[doc = "< The last location to which the range was prefetched"]
    pub const hipMemRangeAttributeLastPrefetchLocation: hipMemRangeAttribute =
        hipMemRangeAttribute(4);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hipMemRangeAttribute(pub ::std::os::raw::c_uint);
impl hipJitOption {
    pub const hipJitOptionMaxRegisters: hipJitOption = hipJitOption(0);
}
impl hipJitOption {
    pub const hipJitOptionThreadsPerBlock: hipJitOption = hipJitOption(1);
}
impl hipJitOption {
    pub const hipJitOptionWallTime: hipJitOption = hipJitOption(2);
}
impl hipJitOption {
    pub const hipJitOptionInfoLogBuffer: hipJitOption = hipJitOption(3);
}
impl hipJitOption {
    pub const hipJitOptionInfoLogBufferSizeBytes: hipJitOption = hipJitOption(4);
}
impl hipJitOption {
    pub const hipJitOptionErrorLogBuffer: hipJitOption = hipJitOption(5);
}
impl hipJitOption {
    pub const hipJitOptionErrorLogBufferSizeBytes: hipJitOption = hipJitOption(6);
}
impl hipJitOption {
    pub const hipJitOptionOptimizationLevel: hipJitOption = hipJitOption(7);
}
impl hipJitOption {
    pub const hipJitOptionTargetFromContext: hipJitOption = hipJitOption(8);
}
impl hipJitOption {
    pub const hipJitOptionTarget: hipJitOption = hipJitOption(9);
}
impl hipJitOption {
    pub const hipJitOptionFallbackStrategy: hipJitOption = hipJitOption(10);
}
impl hipJitOption {
    pub const hipJitOptionGenerateDebugInfo: hipJitOption = hipJitOption(11);
}
impl hipJitOption {
    pub const hipJitOptionLogVerbose: hipJitOption = hipJitOption(12);
}
impl hipJitOption {
    pub const hipJitOptionGenerateLineInfo: hipJitOption = hipJitOption(13);
}
impl hipJitOption {
    pub const hipJitOptionCacheMode: hipJitOption = hipJitOption(14);
}
impl hipJitOption {
    pub const hipJitOptionSm3xOpt: hipJitOption = hipJitOption(15);
}
impl hipJitOption {
    pub const hipJitOptionFastCompile: hipJitOption = hipJitOption(16);
}
impl hipJitOption {
    pub const hipJitOptionNumOptions: hipJitOption = hipJitOption(17);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hipJitOption(pub ::std::os::raw::c_uint);
impl hipFuncAttribute {
    pub const hipFuncAttributeMaxDynamicSharedMemorySize: hipFuncAttribute = hipFuncAttribute(8);
}
impl hipFuncAttribute {
    pub const hipFuncAttributePreferredSharedMemoryCarveout: hipFuncAttribute = hipFuncAttribute(9);
}
impl hipFuncAttribute {
    pub const hipFuncAttributeMax: hipFuncAttribute = hipFuncAttribute(10);
}
#[repr(transparent)]
#[doc = " @warning On AMD devices and some Nvidia devices, these hints and controls are ignored."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hipFuncAttribute(pub ::std::os::raw::c_uint);
impl hipFuncCache_t {
    #[doc = "< no preference for shared memory or L1 (default)"]
    pub const hipFuncCachePreferNone: hipFuncCache_t = hipFuncCache_t(0);
}
impl hipFuncCache_t {
    #[doc = "< prefer larger shared memory and smaller L1 cache"]
    pub const hipFuncCachePreferShared: hipFuncCache_t = hipFuncCache_t(1);
}
impl hipFuncCache_t {
    #[doc = "< prefer larger L1 cache and smaller shared memory"]
    pub const hipFuncCachePreferL1: hipFuncCache_t = hipFuncCache_t(2);
}
impl hipFuncCache_t {
    #[doc = "< prefer equal size L1 cache and shared memory"]
    pub const hipFuncCachePreferEqual: hipFuncCache_t = hipFuncCache_t(3);
}
#[repr(transparent)]
#[doc = " @warning On AMD devices and some Nvidia devices, these hints and controls are ignored."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hipFuncCache_t(pub ::std::os::raw::c_uint);
impl hipSharedMemConfig {
    #[doc = "< The compiler selects a device-specific value for the banking."]
    pub const hipSharedMemBankSizeDefault: hipSharedMemConfig = hipSharedMemConfig(0);
}
impl hipSharedMemConfig {
    #[doc = "< Shared mem is banked at 4-bytes intervals and performs best"]
    #[doc = "< when adjacent threads access data 4 bytes apart."]
    pub const hipSharedMemBankSizeFourByte: hipSharedMemConfig = hipSharedMemConfig(1);
}
impl hipSharedMemConfig {
    #[doc = "< Shared mem is banked at 8-byte intervals and performs best"]
    #[doc = "< when adjacent threads access data 4 bytes apart."]
    pub const hipSharedMemBankSizeEightByte: hipSharedMemConfig = hipSharedMemConfig(2);
}
#[repr(transparent)]
#[doc = " @warning On AMD devices and some Nvidia devices, these hints and controls are ignored."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hipSharedMemConfig(pub ::std::os::raw::c_uint);
#[doc = " Struct for data in 3D"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dim3 {
    #[doc = "< x"]
    pub x: u32,
    #[doc = "< y"]
    pub y: u32,
    #[doc = "< z"]
    pub z: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipLaunchParams_t {
    #[doc = "< Device function symbol"]
    pub func: *mut ::std::os::raw::c_void,
    #[doc = "< Grid dimentions"]
    pub gridDim: dim3,
    #[doc = "< Block dimentions"]
    pub blockDim: dim3,
    #[doc = "< Arguments"]
    pub args: *mut *mut ::std::os::raw::c_void,
    #[doc = "< Shared memory"]
    pub sharedMem: usize,
    #[doc = "< Stream identifier"]
    pub stream: hipStream_t,
}
pub type hipLaunchParams = hipLaunchParams_t;
impl hipExternalMemoryHandleType_enum {
    pub const hipExternalMemoryHandleTypeOpaqueFd: hipExternalMemoryHandleType_enum =
        hipExternalMemoryHandleType_enum(1);
}
impl hipExternalMemoryHandleType_enum {
    pub const hipExternalMemoryHandleTypeOpaqueWin32: hipExternalMemoryHandleType_enum =
        hipExternalMemoryHandleType_enum(2);
}
impl hipExternalMemoryHandleType_enum {
    pub const hipExternalMemoryHandleTypeOpaqueWin32Kmt: hipExternalMemoryHandleType_enum =
        hipExternalMemoryHandleType_enum(3);
}
impl hipExternalMemoryHandleType_enum {
    pub const hipExternalMemoryHandleTypeD3D12Heap: hipExternalMemoryHandleType_enum =
        hipExternalMemoryHandleType_enum(4);
}
impl hipExternalMemoryHandleType_enum {
    pub const hipExternalMemoryHandleTypeD3D12Resource: hipExternalMemoryHandleType_enum =
        hipExternalMemoryHandleType_enum(5);
}
impl hipExternalMemoryHandleType_enum {
    pub const hipExternalMemoryHandleTypeD3D11Resource: hipExternalMemoryHandleType_enum =
        hipExternalMemoryHandleType_enum(6);
}
impl hipExternalMemoryHandleType_enum {
    pub const hipExternalMemoryHandleTypeD3D11ResourceKmt: hipExternalMemoryHandleType_enum =
        hipExternalMemoryHandleType_enum(7);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hipExternalMemoryHandleType_enum(pub ::std::os::raw::c_uint);
pub use self::hipExternalMemoryHandleType_enum as hipExternalMemoryHandleType;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hipExternalMemoryHandleDesc_st {
    pub type_: hipExternalMemoryHandleType,
    pub handle: hipExternalMemoryHandleDesc_st__bindgen_ty_1,
    pub size: ::std::os::raw::c_ulonglong,
    pub flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hipExternalMemoryHandleDesc_st__bindgen_ty_1 {
    pub fd: ::std::os::raw::c_int,
    pub win32: hipExternalMemoryHandleDesc_st__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipExternalMemoryHandleDesc_st__bindgen_ty_1__bindgen_ty_1 {
    pub handle: *mut ::std::os::raw::c_void,
    pub name: *const ::std::os::raw::c_void,
}
pub type hipExternalMemoryHandleDesc = hipExternalMemoryHandleDesc_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipExternalMemoryBufferDesc_st {
    pub offset: ::std::os::raw::c_ulonglong,
    pub size: ::std::os::raw::c_ulonglong,
    pub flags: ::std::os::raw::c_uint,
}
pub type hipExternalMemoryBufferDesc = hipExternalMemoryBufferDesc_st;
pub type hipExternalMemory_t = *mut ::std::os::raw::c_void;
extern "C" {
    #[doc = " @brief Explicitly initializes the HIP runtime."]
    #[doc = ""]
    #[doc = " Most HIP APIs implicitly initialize the HIP runtime."]
    #[doc = " This API provides control over the timing of the initialization."]
    pub fn hipInit(flags: ::std::os::raw::c_uint) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns the approximate HIP driver version."]
    #[doc = ""]
    #[doc = " @param [out] driverVersion"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInavlidValue"]
    #[doc = ""]
    #[doc = " @warning The HIP feature set does not correspond to an exact CUDA SDK driver revision."]
    #[doc = " This function always set *driverVersion to 4 as an approximation though HIP supports"]
    #[doc = " some features which were introduced in later CUDA SDK revisions."]
    #[doc = " HIP apps code should not rely on the driver revision number here and should"]
    #[doc = " use arch feature flags to test device capabilities or conditional compilation."]
    #[doc = ""]
    #[doc = " @see hipRuntimeGetVersion"]
    pub fn hipDriverGetVersion(driverVersion: *mut ::std::os::raw::c_int) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns the approximate HIP Runtime version."]
    #[doc = ""]
    #[doc = " @param [out] runtimeVersion"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInavlidValue"]
    #[doc = ""]
    #[doc = " @warning On HIP/HCC path this function returns HIP runtime patch version however on"]
    #[doc = " HIP/NVCC path this function return CUDA runtime version."]
    #[doc = ""]
    #[doc = " @see hipDriverGetVersion"]
    pub fn hipRuntimeGetVersion(runtimeVersion: *mut ::std::os::raw::c_int) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns a handle to a compute device"]
    #[doc = " @param [out] device"]
    #[doc = " @param [in] ordinal"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInavlidDevice"]
    pub fn hipDeviceGet(device: *mut hipDevice_t, ordinal: ::std::os::raw::c_int) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns the compute capability of the device"]
    #[doc = " @param [out] major"]
    #[doc = " @param [out] minor"]
    #[doc = " @param [in] device"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInavlidDevice"]
    pub fn hipDeviceComputeCapability(
        major: *mut ::std::os::raw::c_int,
        minor: *mut ::std::os::raw::c_int,
        device: hipDevice_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns an identifer string for the device."]
    #[doc = " @param [out] name"]
    #[doc = " @param [in] len"]
    #[doc = " @param [in] device"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInavlidDevice"]
    pub fn hipDeviceGetName(
        name: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        device: hipDevice_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns a value for attr of link between two devices"]
    #[doc = " @param [out] value"]
    #[doc = " @param [in] attr"]
    #[doc = " @param [in] srcDevice"]
    #[doc = " @param [in] dstDevice"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInavlidDevice"]
    pub fn hipDeviceGetP2PAttribute(
        value: *mut ::std::os::raw::c_int,
        attr: hipDeviceP2PAttr,
        srcDevice: ::std::os::raw::c_int,
        dstDevice: ::std::os::raw::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns a PCI Bus Id string for the device, overloaded to take int device ID."]
    #[doc = " @param [out] pciBusId"]
    #[doc = " @param [in] len"]
    #[doc = " @param [in] device"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInavlidDevice"]
    pub fn hipDeviceGetPCIBusId(
        pciBusId: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        device: ::std::os::raw::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns a handle to a compute device."]
    #[doc = " @param [out] device handle"]
    #[doc = " @param [in] PCI Bus ID"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInavlidDevice, #hipErrorInvalidValue"]
    pub fn hipDeviceGetByPCIBusId(
        device: *mut ::std::os::raw::c_int,
        pciBusId: *const ::std::os::raw::c_char,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns the total amount of memory on the device."]
    #[doc = " @param [out] bytes"]
    #[doc = " @param [in] device"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInavlidDevice"]
    pub fn hipDeviceTotalMem(bytes: *mut usize, device: hipDevice_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Waits on all active streams on current device"]
    #[doc = ""]
    #[doc = " When this command is invoked, the host thread gets blocked until all the commands associated"]
    #[doc = " with streams associated with the device. HIP does not support multiple blocking modes (yet!)."]
    #[doc = ""]
    #[doc = " @returns #hipSuccess"]
    #[doc = ""]
    #[doc = " @see hipSetDevice, hipDeviceReset"]
    pub fn hipDeviceSynchronize() -> hipError_t;
}
extern "C" {
    #[doc = " @brief The state of current device is discarded and updated to a fresh state."]
    #[doc = ""]
    #[doc = " Calling this function deletes all streams created, memory allocated, kernels running, events"]
    #[doc = " created. Make sure that no other thread is using the device or streams, memory, kernels, events"]
    #[doc = " associated with the current device."]
    #[doc = ""]
    #[doc = " @returns #hipSuccess"]
    #[doc = ""]
    #[doc = " @see hipDeviceSynchronize"]
    pub fn hipDeviceReset() -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set default device to be used for subsequent hip API calls from this thread."]
    #[doc = ""]
    #[doc = " @param[in] deviceId Valid device in range 0...hipGetDeviceCount()."]
    #[doc = ""]
    #[doc = " Sets @p device as the default device for the calling host thread.  Valid device id's are 0..."]
    #[doc = " (hipGetDeviceCount()-1)."]
    #[doc = ""]
    #[doc = " Many HIP APIs implicitly use the \"default device\" :"]
    #[doc = ""]
    #[doc = " - Any device memory subsequently allocated from this host thread (using hipMalloc) will be"]
    #[doc = " allocated on device."]
    #[doc = " - Any streams or events created from this host thread will be associated with device."]
    #[doc = " - Any kernels launched from this host thread (using hipLaunchKernel) will be executed on device"]
    #[doc = " (unless a specific stream is specified, in which case the device associated with that stream will"]
    #[doc = " be used)."]
    #[doc = ""]
    #[doc = " This function may be called from any host thread.  Multiple host threads may use the same device."]
    #[doc = " This function does no synchronization with the previous or new device, and has very little"]
    #[doc = " runtime overhead. Applications can use hipSetDevice to quickly switch the default device before"]
    #[doc = " making a HIP runtime call which uses the default device."]
    #[doc = ""]
    #[doc = " The default device is stored in thread-local-storage for each thread."]
    #[doc = " Thread-pool implementations may inherit the default device of the previous thread.  A good"]
    #[doc = " practice is to always call hipSetDevice at the start of HIP coding sequency to establish a known"]
    #[doc = " standard device."]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorDeviceAlreadyInUse"]
    #[doc = ""]
    #[doc = " @see hipGetDevice, hipGetDeviceCount"]
    pub fn hipSetDevice(deviceId: ::std::os::raw::c_int) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return the default device id for the calling host thread."]
    #[doc = ""]
    #[doc = " @param [out] device *device is written with the default device"]
    #[doc = ""]
    #[doc = " HIP maintains an default device for each thread using thread-local-storage."]
    #[doc = " This device is used implicitly for HIP runtime APIs called by this thread."]
    #[doc = " hipGetDevice returns in * @p device the default device for the calling host thread."]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = " @see hipSetDevice, hipGetDevicesizeBytes"]
    pub fn hipGetDevice(deviceId: *mut ::std::os::raw::c_int) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return number of compute-capable devices."]
    #[doc = ""]
    #[doc = " @param [output] count Returns number of compute-capable devices."]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorNoDevice"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " Returns in @p *count the number of devices that have ability to run compute commands.  If there"]
    #[doc = " are no such devices, then @ref hipGetDeviceCount will return #hipErrorNoDevice. If 1 or more"]
    #[doc = " devices can be found, then hipGetDeviceCount returns #hipSuccess."]
    pub fn hipGetDeviceCount(count: *mut ::std::os::raw::c_int) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Query for a specific device attribute."]
    #[doc = ""]
    #[doc = " @param [out] pi pointer to value to return"]
    #[doc = " @param [in] attr attribute to query"]
    #[doc = " @param [in] deviceId which device to query for information"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue"]
    pub fn hipDeviceGetAttribute(
        pi: *mut ::std::os::raw::c_int,
        attr: hipDeviceAttribute_t,
        deviceId: ::std::os::raw::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns device properties."]
    #[doc = ""]
    #[doc = " @param [out] prop written with device properties"]
    #[doc = " @param [in]  deviceId which device to query for information"]
    #[doc = ""]
    #[doc = " @return #hipSuccess, #hipErrorInvalidDevice"]
    #[doc = " @bug HCC always returns 0 for maxThreadsPerMultiProcessor"]
    #[doc = " @bug HCC always returns 0 for regsPerBlock"]
    #[doc = " @bug HCC always returns 0 for l2CacheSize"]
    #[doc = ""]
    #[doc = " Populates hipGetDeviceProperties with information for the specified device."]
    pub fn hipGetDeviceProperties(
        prop: *mut hipDeviceProp_t,
        deviceId: ::std::os::raw::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set L1/Shared cache partition."]
    #[doc = ""]
    #[doc = " @param [in] cacheConfig"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorNotInitialized"]
    #[doc = " Note: AMD devices and some Nvidia GPUS do not support reconfigurable cache.  This hint is ignored"]
    #[doc = " on those architectures."]
    #[doc = ""]
    pub fn hipDeviceSetCacheConfig(cacheConfig: hipFuncCache_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set Cache configuration for a specific function"]
    #[doc = ""]
    #[doc = " @param [in] cacheConfig"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorNotInitialized"]
    #[doc = " Note: AMD devices and some Nvidia GPUS do not support reconfigurable cache.  This hint is ignored"]
    #[doc = " on those architectures."]
    #[doc = ""]
    pub fn hipDeviceGetCacheConfig(cacheConfig: *mut hipFuncCache_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get Resource limits of current device"]
    #[doc = ""]
    #[doc = " @param [out] pValue"]
    #[doc = " @param [in]  limit"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorUnsupportedLimit, #hipErrorInvalidValue"]
    #[doc = " Note: Currently, only hipLimitMallocHeapSize is available"]
    #[doc = ""]
    pub fn hipDeviceGetLimit(pValue: *mut usize, limit: hipLimit_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns bank width of shared memory for current device"]
    #[doc = ""]
    #[doc = " @param [out] pConfig"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    #[doc = ""]
    #[doc = " Note: AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is"]
    #[doc = " ignored on those architectures."]
    #[doc = ""]
    pub fn hipDeviceGetSharedMemConfig(pConfig: *mut hipSharedMemConfig) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets the flags set for current device"]
    #[doc = ""]
    #[doc = " @param [out] flags"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue"]
    pub fn hipGetDeviceFlags(flags: *mut ::std::os::raw::c_uint) -> hipError_t;
}
extern "C" {
    #[doc = " @brief The bank width of shared memory on current device is set"]
    #[doc = ""]
    #[doc = " @param [in] config"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    #[doc = ""]
    #[doc = " Note: AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is"]
    #[doc = " ignored on those architectures."]
    #[doc = ""]
    pub fn hipDeviceSetSharedMemConfig(config: hipSharedMemConfig) -> hipError_t;
}
extern "C" {
    #[doc = " @brief The current device behavior is changed according the flags passed."]
    #[doc = ""]
    #[doc = " @param [in] flags"]
    #[doc = ""]
    #[doc = " The schedule flags impact how HIP waits for the completion of a command running on a device."]
    #[doc = " hipDeviceScheduleSpin         : HIP runtime will actively spin in the thread which submitted the"]
    #[doc = " work until the command completes.  This offers the lowest latency, but will consume a CPU core"]
    #[doc = " and may increase power. hipDeviceScheduleYield        : The HIP runtime will yield the CPU to"]
    #[doc = " system so that other tasks can use it.  This may increase latency to detect the completion but"]
    #[doc = " will consume less power and is friendlier to other tasks in the system."]
    #[doc = " hipDeviceScheduleBlockingSync : On ROCm platform, this is a synonym for hipDeviceScheduleYield."]
    #[doc = " hipDeviceScheduleAuto         : Use a hueristic to select between Spin and Yield modes.  If the"]
    #[doc = " number of HIP contexts is greater than the number of logical processors in the system, use Spin"]
    #[doc = " scheduling.  Else use Yield scheduling."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " hipDeviceMapHost              : Allow mapping host memory.  On ROCM, this is always allowed and"]
    #[doc = " the flag is ignored. hipDeviceLmemResizeToMax      : @warning ROCm silently ignores this flag."]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorSetOnActiveProcess"]
    #[doc = ""]
    #[doc = ""]
    pub fn hipSetDeviceFlags(flags: ::std::os::raw::c_uint) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Device which matches hipDeviceProp_t is returned"]
    #[doc = ""]
    #[doc = " @param [out] device ID"]
    #[doc = " @param [in]  device properties pointer"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipChooseDevice(
        device: *mut ::std::os::raw::c_int,
        prop: *const hipDeviceProp_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns the link type and hop count between two devices"]
    #[doc = ""]
    #[doc = " @param [in] device1 Ordinal for device1"]
    #[doc = " @param [in] device2 Ordinal for device2"]
    #[doc = " @param [out] linktype Returns the link type (See hsa_amd_link_info_type_t) between the two devices"]
    #[doc = " @param [out] hopcount Returns the hop count between the two devices"]
    #[doc = ""]
    #[doc = " Queries and returns the HSA link type and the hop count between the two specified devices."]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipInvalidDevice, #hipErrorRuntimeOther"]
    pub fn hipExtGetLinkTypeAndHopCount(
        device1: ::std::os::raw::c_int,
        device2: ::std::os::raw::c_int,
        linktype: *mut u32,
        hopcount: *mut u32,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets an interprocess memory handle for an existing device memory"]
    #[doc = "          allocation"]
    #[doc = ""]
    #[doc = " Takes a pointer to the base of an existing device memory allocation created"]
    #[doc = " with hipMalloc and exports it for use in another process. This is a"]
    #[doc = " lightweight operation and may be called multiple times on an allocation"]
    #[doc = " without adverse effects."]
    #[doc = ""]
    #[doc = " If a region of memory is freed with hipFree and a subsequent call"]
    #[doc = " to hipMalloc returns memory with the same device address,"]
    #[doc = " hipIpcGetMemHandle will return a unique handle for the"]
    #[doc = " new memory."]
    #[doc = ""]
    #[doc = " @param handle - Pointer to user allocated hipIpcMemHandle to return"]
    #[doc = "                    the handle in."]
    #[doc = " @param devPtr - Base pointer to previously allocated device memory"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = " hipSuccess,"]
    #[doc = " hipErrorInvalidHandle,"]
    #[doc = " hipErrorOutOfMemory,"]
    #[doc = " hipErrorMapFailed,"]
    #[doc = ""]
    pub fn hipIpcGetMemHandle(
        handle: *mut hipIpcMemHandle_t,
        devPtr: *mut ::std::os::raw::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Opens an interprocess memory handle exported from another process"]
    #[doc = "          and returns a device pointer usable in the local process."]
    #[doc = ""]
    #[doc = " Maps memory exported from another process with hipIpcGetMemHandle into"]
    #[doc = " the current device address space. For contexts on different devices"]
    #[doc = " hipIpcOpenMemHandle can attempt to enable peer access between the"]
    #[doc = " devices as if the user called hipDeviceEnablePeerAccess. This behavior is"]
    #[doc = " controlled by the hipIpcMemLazyEnablePeerAccess flag."]
    #[doc = " hipDeviceCanAccessPeer can determine if a mapping is possible."]
    #[doc = ""]
    #[doc = " Contexts that may open hipIpcMemHandles are restricted in the following way."]
    #[doc = " hipIpcMemHandles from each device in a given process may only be opened"]
    #[doc = " by one context per device per other process."]
    #[doc = ""]
    #[doc = " Memory returned from hipIpcOpenMemHandle must be freed with"]
    #[doc = " hipIpcCloseMemHandle."]
    #[doc = ""]
    #[doc = " Calling hipFree on an exported memory region before calling"]
    #[doc = " hipIpcCloseMemHandle in the importing context will result in undefined"]
    #[doc = " behavior."]
    #[doc = ""]
    #[doc = " @param devPtr - Returned device pointer"]
    #[doc = " @param handle - hipIpcMemHandle to open"]
    #[doc = " @param flags  - Flags for this operation. Must be specified as hipIpcMemLazyEnablePeerAccess"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = " hipSuccess,"]
    #[doc = " hipErrorMapFailed,"]
    #[doc = " hipErrorInvalidHandle,"]
    #[doc = " hipErrorTooManyPeers"]
    #[doc = ""]
    #[doc = " @note No guarantees are made about the address returned in @p *devPtr."]
    #[doc = " In particular, multiple processes may not receive the same address for the same @p handle."]
    #[doc = ""]
    pub fn hipIpcOpenMemHandle(
        devPtr: *mut *mut ::std::os::raw::c_void,
        handle: hipIpcMemHandle_t,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Close memory mapped with hipIpcOpenMemHandle"]
    #[doc = ""]
    #[doc = " Unmaps memory returnd by hipIpcOpenMemHandle. The original allocation"]
    #[doc = " in the exporting process as well as imported mappings in other processes"]
    #[doc = " will be unaffected."]
    #[doc = ""]
    #[doc = " Any resources used to enable peer access will be freed if this is the"]
    #[doc = " last mapping using them."]
    #[doc = ""]
    #[doc = " @param devPtr - Device pointer returned by hipIpcOpenMemHandle"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = " hipSuccess,"]
    #[doc = " hipErrorMapFailed,"]
    #[doc = " hipErrorInvalidHandle,"]
    #[doc = ""]
    pub fn hipIpcCloseMemHandle(devPtr: *mut ::std::os::raw::c_void) -> hipError_t;
}
extern "C" {
    pub fn hipIpcGetEventHandle(handle: *mut hipIpcEventHandle_t, event: hipEvent_t) -> hipError_t;
}
extern "C" {
    pub fn hipIpcOpenEventHandle(event: *mut hipEvent_t, handle: hipIpcEventHandle_t)
        -> hipError_t;
}
extern "C" {
    #[doc = "  @defgroup Execution Execution Control"]
    #[doc = "  @{"]
    #[doc = "  This section describes the execution control functions of HIP runtime API."]
    #[doc = ""]
    #[doc = " @brief Set attribute for a specific function"]
    #[doc = ""]
    #[doc = " @param [in] func;"]
    #[doc = " @param [in] attr;"]
    #[doc = " @param [in] value;"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidDeviceFunction, #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = " Note: AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is"]
    #[doc = " ignored on those architectures."]
    #[doc = ""]
    pub fn hipFuncSetAttribute(
        func: *const ::std::os::raw::c_void,
        attr: hipFuncAttribute,
        value: ::std::os::raw::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set Cache configuration for a specific function"]
    #[doc = ""]
    #[doc = " @param [in] config;"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorNotInitialized"]
    #[doc = " Note: AMD devices and some Nvidia GPUS do not support reconfigurable cache.  This hint is ignored"]
    #[doc = " on those architectures."]
    #[doc = ""]
    pub fn hipFuncSetCacheConfig(
        func: *const ::std::os::raw::c_void,
        config: hipFuncCache_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set shared memory configuation for a specific function"]
    #[doc = ""]
    #[doc = " @param [in] func"]
    #[doc = " @param [in] config"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidDeviceFunction, #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = " Note: AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is"]
    #[doc = " ignored on those architectures."]
    #[doc = ""]
    pub fn hipFuncSetSharedMemConfig(
        func: *const ::std::os::raw::c_void,
        config: hipSharedMemConfig,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return last error returned by any HIP runtime API call and resets the stored error code to"]
    #[doc = " #hipSuccess"]
    #[doc = ""]
    #[doc = " @returns return code from last HIP called from the active host thread"]
    #[doc = ""]
    #[doc = " Returns the last error that has been returned by any of the runtime calls in the same host"]
    #[doc = " thread, and then resets the saved error to #hipSuccess."]
    #[doc = ""]
    #[doc = " @see hipGetErrorString, hipGetLastError, hipPeakAtLastError, hipError_t"]
    pub fn hipGetLastError() -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return last error returned by any HIP runtime API call."]
    #[doc = ""]
    #[doc = " @return #hipSuccess"]
    #[doc = ""]
    #[doc = " Returns the last error that has been returned by any of the runtime calls in the same host"]
    #[doc = " thread. Unlike hipGetLastError, this function does not reset the saved error code."]
    #[doc = ""]
    #[doc = " @see hipGetErrorString, hipGetLastError, hipPeakAtLastError, hipError_t"]
    pub fn hipPeekAtLastError() -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return name of the specified error code in text form."]
    #[doc = ""]
    #[doc = " @param hip_error Error code to convert to name."]
    #[doc = " @return const char pointer to the NULL-terminated error name"]
    #[doc = ""]
    #[doc = " @see hipGetErrorString, hipGetLastError, hipPeakAtLastError, hipError_t"]
    pub fn hipGetErrorName(hip_error: hipError_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Return handy text string message to explain the error which occurred"]
    #[doc = ""]
    #[doc = " @param hipError Error code to convert to string."]
    #[doc = " @return const char pointer to the NULL-terminated error string"]
    #[doc = ""]
    #[doc = " @warning : on HCC, this function returns the name of the error (same as hipGetErrorName)"]
    #[doc = ""]
    #[doc = " @see hipGetErrorName, hipGetLastError, hipPeakAtLastError, hipError_t"]
    pub fn hipGetErrorString(hipError: hipError_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Create an asynchronous stream."]
    #[doc = ""]
    #[doc = " @param[in, out] stream Valid pointer to hipStream_t.  This function writes the memory with the"]
    #[doc = " newly created stream."]
    #[doc = " @return #hipSuccess, #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = " Create a new asynchronous stream.  @p stream returns an opaque handle that can be used to"]
    #[doc = " reference the newly created stream in subsequent hipStream* commands.  The stream is allocated on"]
    #[doc = " the heap and will remain allocated even if the handle goes out-of-scope.  To release the memory"]
    #[doc = " used by the stream, applicaiton must call hipStreamDestroy."]
    #[doc = ""]
    #[doc = " @return #hipSuccess, #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = " @see hipStreamCreateWithFlags, hipStreamCreateWithPriority, hipStreamSynchronize, hipStreamWaitEvent, hipStreamDestroy"]
    pub fn hipStreamCreate(stream: *mut hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Create an asynchronous stream."]
    #[doc = ""]
    #[doc = " @param[in, out] stream Pointer to new stream"]
    #[doc = " @param[in ] flags to control stream creation."]
    #[doc = " @return #hipSuccess, #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = " Create a new asynchronous stream.  @p stream returns an opaque handle that can be used to"]
    #[doc = " reference the newly created stream in subsequent hipStream* commands.  The stream is allocated on"]
    #[doc = " the heap and will remain allocated even if the handle goes out-of-scope.  To release the memory"]
    #[doc = " used by the stream, applicaiton must call hipStreamDestroy. Flags controls behavior of the"]
    #[doc = " stream.  See #hipStreamDefault, #hipStreamNonBlocking."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @see hipStreamCreate, hipStreamCreateWithPriority, hipStreamSynchronize, hipStreamWaitEvent, hipStreamDestroy"]
    pub fn hipStreamCreateWithFlags(
        stream: *mut hipStream_t,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Create an asynchronous stream with the specified priority."]
    #[doc = ""]
    #[doc = " @param[in, out] stream Pointer to new stream"]
    #[doc = " @param[in ] flags to control stream creation."]
    #[doc = " @param[in ] priority of the stream. Lower numbers represent higher priorities."]
    #[doc = " @return #hipSuccess, #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = " Create a new asynchronous stream with the specified priority.  @p stream returns an opaque handle"]
    #[doc = " that can be used to reference the newly created stream in subsequent hipStream* commands.  The"]
    #[doc = " stream is allocated on the heap and will remain allocated even if the handle goes out-of-scope."]
    #[doc = " To release the memory used by the stream, applicaiton must call hipStreamDestroy. Flags controls"]
    #[doc = " behavior of the stream.  See #hipStreamDefault, #hipStreamNonBlocking."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @see hipStreamCreate, hipStreamSynchronize, hipStreamWaitEvent, hipStreamDestroy"]
    pub fn hipStreamCreateWithPriority(
        stream: *mut hipStream_t,
        flags: ::std::os::raw::c_uint,
        priority: ::std::os::raw::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns numerical values that correspond to the least and greatest stream priority."]
    #[doc = ""]
    #[doc = " @param[in, out] leastPriority pointer in which value corresponding to least priority is returned."]
    #[doc = " @param[in, out] greatestPriority pointer in which value corresponding to greatest priority is returned."]
    #[doc = ""]
    #[doc = " Returns in *leastPriority and *greatestPriority the numerical values that correspond to the least"]
    #[doc = " and greatest stream priority respectively. Stream priorities follow a convention where lower numbers"]
    #[doc = " imply greater priorities. The range of meaningful stream priorities is given by"]
    #[doc = " [*greatestPriority, *leastPriority]. If the user attempts to create a stream with a priority value"]
    #[doc = " that is outside the the meaningful range as specified by this API, the priority is automatically"]
    #[doc = " clamped to within the valid range."]
    pub fn hipDeviceGetStreamPriorityRange(
        leastPriority: *mut ::std::os::raw::c_int,
        greatestPriority: *mut ::std::os::raw::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Destroys the specified stream."]
    #[doc = ""]
    #[doc = " @param[in, out] stream Valid pointer to hipStream_t.  This function writes the memory with the"]
    #[doc = " newly created stream."]
    #[doc = " @return #hipSuccess #hipErrorInvalidHandle"]
    #[doc = ""]
    #[doc = " Destroys the specified stream."]
    #[doc = ""]
    #[doc = " If commands are still executing on the specified stream, some may complete execution before the"]
    #[doc = " queue is deleted."]
    #[doc = ""]
    #[doc = " The queue may be destroyed while some commands are still inflight, or may wait for all commands"]
    #[doc = " queued to the stream before destroying it."]
    #[doc = ""]
    #[doc = " @see hipStreamCreate, hipStreamCreateWithFlags, hipStreamCreateWithPriority, hipStreamQuery, hipStreamWaitEvent,"]
    #[doc = " hipStreamSynchronize"]
    pub fn hipStreamDestroy(stream: hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return #hipSuccess if all of the operations in the specified @p stream have completed, or"]
    #[doc = " #hipErrorNotReady if not."]
    #[doc = ""]
    #[doc = " @param[in] stream stream to query"]
    #[doc = ""]
    #[doc = " @return #hipSuccess, #hipErrorNotReady, #hipErrorInvalidHandle"]
    #[doc = ""]
    #[doc = " This is thread-safe and returns a snapshot of the current state of the queue.  However, if other"]
    #[doc = " host threads are sending work to the stream, the status may change immediately after the function"]
    #[doc = " is called.  It is typically used for debug."]
    #[doc = ""]
    #[doc = " @see hipStreamCreate, hipStreamCreateWithFlags, hipStreamCreateWithPriority, hipStreamWaitEvent, hipStreamSynchronize,"]
    #[doc = " hipStreamDestroy"]
    pub fn hipStreamQuery(stream: hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Wait for all commands in stream to complete."]
    #[doc = ""]
    #[doc = " @param[in] stream stream identifier."]
    #[doc = ""]
    #[doc = " @return #hipSuccess, #hipErrorInvalidHandle"]
    #[doc = ""]
    #[doc = " This command is host-synchronous : the host will block until the specified stream is empty."]
    #[doc = ""]
    #[doc = " This command follows standard null-stream semantics.  Specifically, specifying the null stream"]
    #[doc = " will cause the command to wait for other streams on the same device to complete all pending"]
    #[doc = " operations."]
    #[doc = ""]
    #[doc = " This command honors the hipDeviceLaunchBlocking flag, which controls whether the wait is active"]
    #[doc = " or blocking."]
    #[doc = ""]
    #[doc = " @see hipStreamCreate, hipStreamCreateWithFlags, hipStreamCreateWithPriority, hipStreamWaitEvent, hipStreamDestroy"]
    #[doc = ""]
    pub fn hipStreamSynchronize(stream: hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Make the specified compute stream wait for an event"]
    #[doc = ""]
    #[doc = " @param[in] stream stream to make wait."]
    #[doc = " @param[in] event event to wait on"]
    #[doc = " @param[in] flags control operation [must be 0]"]
    #[doc = ""]
    #[doc = " @return #hipSuccess, #hipErrorInvalidHandle"]
    #[doc = ""]
    #[doc = " This function inserts a wait operation into the specified stream."]
    #[doc = " All future work submitted to @p stream will wait until @p event reports completion before"]
    #[doc = " beginning execution."]
    #[doc = ""]
    #[doc = " This function only waits for commands in the current stream to complete.  Notably,, this function"]
    #[doc = " does not impliciy wait for commands in the default stream to complete, even if the specified"]
    #[doc = " stream is created with hipStreamNonBlocking = 0."]
    #[doc = ""]
    #[doc = " @see hipStreamCreate, hipStreamCreateWithFlags, hipStreamCreateWithPriority, hipStreamSynchronize, hipStreamDestroy"]
    pub fn hipStreamWaitEvent(
        stream: hipStream_t,
        event: hipEvent_t,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return flags associated with this stream."]
    #[doc = ""]
    #[doc = " @param[in] stream stream to be queried"]
    #[doc = " @param[in,out] flags Pointer to an unsigned integer in which the stream's flags are returned"]
    #[doc = " @return #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidHandle"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess #hipErrorInvalidValue #hipErrorInvalidHandle"]
    #[doc = ""]
    #[doc = " Return flags associated with this stream in *@p flags."]
    #[doc = ""]
    #[doc = " @see hipStreamCreateWithFlags"]
    pub fn hipStreamGetFlags(stream: hipStream_t, flags: *mut ::std::os::raw::c_uint)
        -> hipError_t;
}
extern "C" {
    #[doc = " @brief Query the priority of a stream."]
    #[doc = ""]
    #[doc = " @param[in] stream stream to be queried"]
    #[doc = " @param[in,out] priority Pointer to an unsigned integer in which the stream's priority is returned"]
    #[doc = " @return #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidHandle"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess #hipErrorInvalidValue #hipErrorInvalidHandle"]
    #[doc = ""]
    #[doc = " Query the priority of a stream. The priority is returned in in priority."]
    #[doc = ""]
    #[doc = " @see hipStreamCreateWithFlags"]
    pub fn hipStreamGetPriority(
        stream: hipStream_t,
        priority: *mut ::std::os::raw::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Create an asynchronous stream with the specified CU mask."]
    #[doc = ""]
    #[doc = " @param[in, out] stream Pointer to new stream"]
    #[doc = " @param[in ] cuMaskSize Size of CU mask bit array passed in."]
    #[doc = " @param[in ] cuMask Bit-vector representing the CU mask. Each active bit represents using one CU."]
    #[doc = " The first 32 bits represent the first 32 CUs, and so on. If its size is greater than physical"]
    #[doc = " CU number (i.e., multiProcessorCount member of hipDeviceProp_t), the extra elements are ignored."]
    #[doc = " It is user's responsibility to make sure the input is meaningful."]
    #[doc = " @return #hipSuccess, #hipErrorInvalidHandle, #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = " Create a new asynchronous stream with the specified CU mask.  @p stream returns an opaque handle"]
    #[doc = " that can be used to reference the newly created stream in subsequent hipStream* commands.  The"]
    #[doc = " stream is allocated on the heap and will remain allocated even if the handle goes out-of-scope."]
    #[doc = " To release the memory used by the stream, application must call hipStreamDestroy."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @see hipStreamCreate, hipStreamSynchronize, hipStreamWaitEvent, hipStreamDestroy"]
    pub fn hipExtStreamCreateWithCUMask(
        stream: *mut hipStream_t,
        cuMaskSize: u32,
        cuMask: *const u32,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get CU mask associated with an asynchronous stream"]
    #[doc = ""]
    #[doc = " @param[in] stream stream to be queried"]
    #[doc = " @param[in] cuMaskSize number of the block of memories (uint32_t *) allocated by user"]
    #[doc = " @param[out] cuMask Pointer to a pre-allocated block of memories (uint32_t *) in which"]
    #[doc = " the stream's CU mask is returned. The CU mask is returned in a chunck of 32 bits where"]
    #[doc = " each active bit represents one active CU"]
    #[doc = " @return #hipSuccess, #hipErrorInvalidHandle, #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = " @see hipStreamCreate, hipStreamSynchronize, hipStreamWaitEvent, hipStreamDestroy"]
    pub fn hipExtStreamGetCUMask(
        stream: hipStream_t,
        cuMaskSize: u32,
        cuMask: *mut u32,
    ) -> hipError_t;
}
#[doc = " Stream CallBack struct"]
pub type hipStreamCallback_t = ::std::option::Option<
    unsafe extern "C" fn(
        stream: hipStream_t,
        status: hipError_t,
        userData: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " @brief Adds a callback to be called on the host after all currently enqueued"]
    #[doc = " items in the stream have completed.  For each"]
    #[doc = " cudaStreamAddCallback call, a callback will be executed exactly once."]
    #[doc = " The callback will block later work in the stream until it is finished."]
    #[doc = " @param[in] stream   - Stream to add callback to"]
    #[doc = " @param[in] callback - The function to call once preceding stream operations are complete"]
    #[doc = " @param[in] userData - User specified data to be passed to the callback function"]
    #[doc = " @param[in] flags    - Reserved for future use, must be 0"]
    #[doc = " @return #hipSuccess, #hipErrorInvalidHandle, #hipErrorNotSupported"]
    #[doc = ""]
    #[doc = " @see hipStreamCreate, hipStreamCreateWithFlags, hipStreamQuery, hipStreamSynchronize,"]
    #[doc = " hipStreamWaitEvent, hipStreamDestroy, hipStreamCreateWithPriority"]
    #[doc = ""]
    pub fn hipStreamAddCallback(
        stream: hipStream_t,
        callback: hipStreamCallback_t,
        userData: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Enqueues a wait command to the stream."]
    #[doc = ""]
    #[doc = " @param [in] stream - Stream identifier"]
    #[doc = " @param [in] ptr    - Pointer to memory object allocated using 'hipMallocSignalMemory' flag"]
    #[doc = " @param [in] value  - Value to be used in compare operation"]
    #[doc = " @param [in] flags  - Defines the compare operation, supported values are hipStreamWaitValueGte"]
    #[doc = " hipStreamWaitValueEq, hipStreamWaitValueAnd and hipStreamWaitValueNor"]
    #[doc = " @param [in] mask   - Mask to be applied on value at memory before it is compared with value,"]
    #[doc = " default value is set to enable every bit"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = " Enqueues a wait command to the stream, all operations enqueued  on this stream after this, will"]
    #[doc = " not execute until the defined wait condition is true."]
    #[doc = ""]
    #[doc = " hipStreamWaitValueGte: waits until *ptr&mask >= value"]
    #[doc = " hipStreamWaitValueEq : waits until *ptr&mask == value"]
    #[doc = " hipStreamWaitValueAnd: waits until ((*ptr&mask) & value) != 0"]
    #[doc = " hipStreamWaitValueNor: waits until ~((*ptr&mask) | (value&mask)) != 0"]
    #[doc = ""]
    #[doc = " @note when using 'hipStreamWaitValueNor', mask is applied on both 'value' and '*ptr'."]
    #[doc = ""]
    #[doc = " @note Support for hipStreamWaitValue32 can be queried using 'hipDeviceGetAttribute()' and"]
    #[doc = " 'hipDeviceAttributeCanUseStreamWaitValue' flag."]
    #[doc = ""]
    #[doc = " @see hipExtMallocWithFlags, hipFree, hipStreamWaitValue64, hipStreamWriteValue64,"]
    #[doc = " hipStreamWriteValue32, hipDeviceGetAttribute"]
    pub fn hipStreamWaitValue32(
        stream: hipStream_t,
        ptr: *mut ::std::os::raw::c_void,
        value: i32,
        flags: ::std::os::raw::c_uint,
        mask: u32,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Enqueues a wait command to the stream."]
    #[doc = ""]
    #[doc = " @param [in] stream - Stream identifier"]
    #[doc = " @param [in] ptr    - Pointer to memory object allocated using 'hipMallocSignalMemory' flag"]
    #[doc = " @param [in] value  - Value to be used in compare operation"]
    #[doc = " @param [in] flags  - Defines the compare operation, supported values are hipStreamWaitValueGte"]
    #[doc = " hipStreamWaitValueEq, hipStreamWaitValueAnd and hipStreamWaitValueNor."]
    #[doc = " @param [in] mask   - Mask to be applied on value at memory before it is compared with value"]
    #[doc = " default value is set to enable every bit"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = " Enqueues a wait command to the stream, all operations enqueued  on this stream after this, will"]
    #[doc = " not execute until the defined wait condition is true."]
    #[doc = ""]
    #[doc = " hipStreamWaitValueGte: waits until *ptr&mask >= value"]
    #[doc = " hipStreamWaitValueEq : waits until *ptr&mask == value"]
    #[doc = " hipStreamWaitValueAnd: waits until ((*ptr&mask) & value) != 0"]
    #[doc = " hipStreamWaitValueNor: waits until ~((*ptr&mask) | (value&mask)) != 0"]
    #[doc = ""]
    #[doc = " @note when using 'hipStreamWaitValueNor', mask is applied on both 'value' and '*ptr'."]
    #[doc = ""]
    #[doc = " @note Support for hipStreamWaitValue64 can be queried using 'hipDeviceGetAttribute()' and"]
    #[doc = " 'hipDeviceAttributeCanUseStreamWaitValue' flag."]
    #[doc = ""]
    #[doc = " @see hipExtMallocWithFlags, hipFree, hipStreamWaitValue32, hipStreamWriteValue64,"]
    #[doc = " hipStreamWriteValue32, hipDeviceGetAttribute"]
    pub fn hipStreamWaitValue64(
        stream: hipStream_t,
        ptr: *mut ::std::os::raw::c_void,
        value: i64,
        flags: ::std::os::raw::c_uint,
        mask: u64,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Enqueues a write command to the stream."]
    #[doc = ""]
    #[doc = " @param [in] stream - Stream identifier"]
    #[doc = " @param [in] ptr    - Pointer to a GPU accessible memory object"]
    #[doc = " @param [in] value  - Value to be written"]
    #[doc = " @param [in] flags  - reserved, ignored for now, will be used in future releases"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = " Enqueues a write command to the stream, write operation is performed after all earlier commands"]
    #[doc = " on this stream have completed the execution."]
    #[doc = ""]
    #[doc = " @see hipExtMallocWithFlags, hipFree, hipStreamWriteValue32, hipStreamWaitValue32,"]
    #[doc = " hipStreamWaitValue64"]
    pub fn hipStreamWriteValue32(
        stream: hipStream_t,
        ptr: *mut ::std::os::raw::c_void,
        value: i32,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Enqueues a write command to the stream."]
    #[doc = ""]
    #[doc = " @param [in] stream - Stream identifier"]
    #[doc = " @param [in] ptr    - Pointer to a GPU accessible memory object"]
    #[doc = " @param [in] value  - Value to be written"]
    #[doc = " @param [in] flags  - reserved, ignored for now, will be used in future releases"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = " Enqueues a write command to the stream, write operation is performed after all earlier commands"]
    #[doc = " on this stream have completed the execution."]
    #[doc = ""]
    #[doc = " @see hipExtMallocWithFlags, hipFree, hipStreamWriteValue32, hipStreamWaitValue32,"]
    #[doc = " hipStreamWaitValue64"]
    pub fn hipStreamWriteValue64(
        stream: hipStream_t,
        ptr: *mut ::std::os::raw::c_void,
        value: i64,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Create an event with the specified flags"]
    #[doc = ""]
    #[doc = " @param[in,out] event Returns the newly created event."]
    #[doc = " @param[in] flags     Flags to control event behavior.  Valid values are #hipEventDefault,"]
    #[doc = "#hipEventBlockingSync, #hipEventDisableTiming, #hipEventInterprocess"]
    #[doc = ""]
    #[doc = " #hipEventDefault : Default flag.  The event will use active synchronization and will support"]
    #[doc = "timing.  Blocking synchronization provides lowest possible latency at the expense of dedicating a"]
    #[doc = "CPU to poll on the event."]
    #[doc = " #hipEventBlockingSync : The event will use blocking synchronization : if hipEventSynchronize is"]
    #[doc = "called on this event, the thread will block until the event completes.  This can increase latency"]
    #[doc = "for the synchroniation but can result in lower power and more resources for other CPU threads."]
    #[doc = " #hipEventDisableTiming : Disable recording of timing information. Events created with this flag"]
    #[doc = "would not record profiling data and provide best performance if used for synchronization."]
    #[doc = ""]
    #[doc = " @warning On AMD platform, hipEventInterprocess support is under development.  Use of this flag"]
    #[doc = "will return an error."]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorInvalidValue,"]
    #[doc = "#hipErrorLaunchFailure, #hipErrorOutOfMemory"]
    #[doc = ""]
    #[doc = " @see hipEventCreate, hipEventSynchronize, hipEventDestroy, hipEventElapsedTime"]
    pub fn hipEventCreateWithFlags(
        event: *mut hipEvent_t,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  Create an event"]
    #[doc = ""]
    #[doc = " @param[in,out] event Returns the newly created event."]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorInvalidValue,"]
    #[doc = " #hipErrorLaunchFailure, #hipErrorOutOfMemory"]
    #[doc = ""]
    #[doc = " @see hipEventCreateWithFlags, hipEventRecord, hipEventQuery, hipEventSynchronize,"]
    #[doc = " hipEventDestroy, hipEventElapsedTime"]
    pub fn hipEventCreate(event: *mut hipEvent_t) -> hipError_t;
}
extern "C" {
    pub fn hipEventRecord(event: hipEvent_t, stream: hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Destroy the specified event."]
    #[doc = ""]
    #[doc = "  @param[in] event Event to destroy."]
    #[doc = "  @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorInvalidValue,"]
    #[doc = " #hipErrorLaunchFailure"]
    #[doc = ""]
    #[doc = "  Releases memory associated with the event.  If the event is recording but has not completed"]
    #[doc = " recording when hipEventDestroy() is called, the function will return immediately and the"]
    #[doc = " completion_future resources will be released later, when the hipDevice is synchronized."]
    #[doc = ""]
    #[doc = " @see hipEventCreate, hipEventCreateWithFlags, hipEventQuery, hipEventSynchronize, hipEventRecord,"]
    #[doc = " hipEventElapsedTime"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess"]
    pub fn hipEventDestroy(event: hipEvent_t) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Wait for an event to complete."]
    #[doc = ""]
    #[doc = "  This function will block until the event is ready, waiting for all previous work in the stream"]
    #[doc = " specified when event was recorded with hipEventRecord()."]
    #[doc = ""]
    #[doc = "  If hipEventRecord() has not been called on @p event, this function returns immediately."]
    #[doc = ""]
    #[doc = "  TODO-hip- This function needs to support hipEventBlockingSync parameter."]
    #[doc = ""]
    #[doc = "  @param[in] event Event on which to wait."]
    #[doc = "  @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized,"]
    #[doc = " #hipErrorInvalidHandle, #hipErrorLaunchFailure"]
    #[doc = ""]
    #[doc = "  @see hipEventCreate, hipEventCreateWithFlags, hipEventQuery, hipEventDestroy, hipEventRecord,"]
    #[doc = " hipEventElapsedTime"]
    pub fn hipEventSynchronize(event: hipEvent_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return the elapsed time between two events."]
    #[doc = ""]
    #[doc = " @param[out] ms : Return time between start and stop in ms."]
    #[doc = " @param[in]   start : Start event."]
    #[doc = " @param[in]   stop  : Stop event."]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotReady, #hipErrorInvalidHandle,"]
    #[doc = " #hipErrorNotInitialized, #hipErrorLaunchFailure"]
    #[doc = ""]
    #[doc = " Computes the elapsed time between two events. Time is computed in ms, with"]
    #[doc = " a resolution of approximately 1 us."]
    #[doc = ""]
    #[doc = " Events which are recorded in a NULL stream will block until all commands"]
    #[doc = " on all other streams complete execution, and then record the timestamp."]
    #[doc = ""]
    #[doc = " Events which are recorded in a non-NULL stream will record their timestamp"]
    #[doc = " when they reach the head of the specified stream, after all previous"]
    #[doc = " commands in that stream have completed executing.  Thus the time that"]
    #[doc = " the event recorded may be significantly after the host calls hipEventRecord()."]
    #[doc = ""]
    #[doc = " If hipEventRecord() has not been called on either event, then #hipErrorInvalidHandle is"]
    #[doc = " returned. If hipEventRecord() has been called on both events, but the timestamp has not yet been"]
    #[doc = " recorded on one or both events (that is, hipEventQuery() would return #hipErrorNotReady on at"]
    #[doc = " least one of the events), then #hipErrorNotReady is returned."]
    #[doc = ""]
    #[doc = " Note, for HIP Events used in kernel dispatch using hipExtLaunchKernelGGL/hipExtLaunchKernel,"]
    #[doc = " events passed in hipExtLaunchKernelGGL/hipExtLaunchKernel are not explicitly recorded and should"]
    #[doc = " only be used to get elapsed time for that specific launch. In case events are used across"]
    #[doc = " multiple dispatches, for example, start and stop events from different hipExtLaunchKernelGGL/"]
    #[doc = " hipExtLaunchKernel calls, they will be treated as invalid unrecorded events, HIP will throw"]
    #[doc = " error \"hipErrorInvalidHandle\" from hipEventElapsedTime."]
    #[doc = ""]
    #[doc = " @see hipEventCreate, hipEventCreateWithFlags, hipEventQuery, hipEventDestroy, hipEventRecord,"]
    #[doc = " hipEventSynchronize"]
    pub fn hipEventElapsedTime(ms: *mut f32, start: hipEvent_t, stop: hipEvent_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Query event status"]
    #[doc = ""]
    #[doc = " @param[in] event Event to query."]
    #[doc = " @returns #hipSuccess, #hipErrorNotReady, #hipErrorInvalidHandle, #hipErrorInvalidValue,"]
    #[doc = " #hipErrorNotInitialized, #hipErrorLaunchFailure"]
    #[doc = ""]
    #[doc = " Query the status of the specified event.  This function will return #hipErrorNotReady if all"]
    #[doc = " commands in the appropriate stream (specified to hipEventRecord()) have completed.  If that work"]
    #[doc = " has not completed, or if hipEventRecord() was not called on the event, then #hipSuccess is"]
    #[doc = " returned."]
    #[doc = ""]
    #[doc = " @see hipEventCreate, hipEventCreateWithFlags, hipEventRecord, hipEventDestroy,"]
    #[doc = " hipEventSynchronize, hipEventElapsedTime"]
    pub fn hipEventQuery(event: hipEvent_t) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Return attributes for the specified pointer"]
    #[doc = ""]
    #[doc = "  @param[out] attributes for the specified pointer"]
    #[doc = "  @param[in]  pointer to get attributes for"]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = "  @see hipGetDeviceCount, hipGetDevice, hipSetDevice, hipChooseDevice"]
    pub fn hipPointerGetAttributes(
        attributes: *mut hipPointerAttribute_t,
        ptr: *const ::std::os::raw::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Imports an external memory object."]
    #[doc = ""]
    #[doc = "  @param[out] extMem_out  Returned handle to an external memory object"]
    #[doc = "  @param[in]  memHandleDesc Memory import handle descriptor"]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = "  @see"]
    pub fn hipImportExternalMemory(
        extMem_out: *mut hipExternalMemory_t,
        memHandleDesc: *const hipExternalMemoryHandleDesc,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Maps a buffer onto an imported memory object."]
    #[doc = ""]
    #[doc = "  @param[out] devPtr Returned device pointer to buffer"]
    #[doc = "  @param[in]  extMem  Handle to external memory object"]
    #[doc = "  @param[in]  bufferDesc  Buffer descriptor"]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = "  @see"]
    pub fn hipExternalMemoryGetMappedBuffer(
        devPtr: *mut *mut ::std::os::raw::c_void,
        extMem: hipExternalMemory_t,
        bufferDesc: *const hipExternalMemoryBufferDesc,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Destroys an external memory object."]
    #[doc = ""]
    #[doc = "  @param[in] extMem  External memory object to be destroyed"]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = "  @see"]
    pub fn hipDestroyExternalMemory(extMem: hipExternalMemory_t) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Allocate memory on the default accelerator"]
    #[doc = ""]
    #[doc = "  @param[out] ptr Pointer to the allocated memory"]
    #[doc = "  @param[in]  size Requested memory size"]
    #[doc = ""]
    #[doc = "  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned."]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorOutOfMemory, #hipErrorInvalidValue (bad context, null *ptr)"]
    #[doc = ""]
    #[doc = "  @see hipMallocPitch, hipFree, hipMallocArray, hipFreeArray, hipMalloc3D, hipMalloc3DArray,"]
    #[doc = " hipHostFree, hipHostMalloc"]
    pub fn hipMalloc(ptr: *mut *mut ::std::os::raw::c_void, size: usize) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Allocate memory on the default accelerator"]
    #[doc = ""]
    #[doc = "  @param[out] ptr Pointer to the allocated memory"]
    #[doc = "  @param[in]  size Requested memory size"]
    #[doc = "  @param[in]  flags Type of memory allocation"]
    #[doc = ""]
    #[doc = "  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned."]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorOutOfMemory, #hipErrorInvalidValue (bad context, null *ptr)"]
    #[doc = ""]
    #[doc = "  @see hipMallocPitch, hipFree, hipMallocArray, hipFreeArray, hipMalloc3D, hipMalloc3DArray,"]
    #[doc = " hipHostFree, hipHostMalloc"]
    pub fn hipExtMallocWithFlags(
        ptr: *mut *mut ::std::os::raw::c_void,
        sizeBytes: usize,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Allocate pinned host memory [Deprecated]"]
    #[doc = ""]
    #[doc = "  @param[out] ptr Pointer to the allocated host pinned memory"]
    #[doc = "  @param[in]  size Requested memory size"]
    #[doc = ""]
    #[doc = "  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned."]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorOutOfMemory"]
    #[doc = ""]
    #[doc = "  @deprecated use hipHostMalloc() instead"]
    pub fn hipMallocHost(ptr: *mut *mut ::std::os::raw::c_void, size: usize) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Allocate pinned host memory [Deprecated]"]
    #[doc = ""]
    #[doc = "  @param[out] ptr Pointer to the allocated host pinned memory"]
    #[doc = "  @param[in]  size Requested memory size"]
    #[doc = ""]
    #[doc = "  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned."]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorOutOfMemory"]
    #[doc = ""]
    #[doc = "  @deprecated use hipHostMalloc() instead"]
    pub fn hipMemAllocHost(ptr: *mut *mut ::std::os::raw::c_void, size: usize) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Allocate device accessible page locked host memory"]
    #[doc = ""]
    #[doc = "  @param[out] ptr Pointer to the allocated host pinned memory"]
    #[doc = "  @param[in]  size Requested memory size"]
    #[doc = "  @param[in]  flags Type of host memory allocation"]
    #[doc = ""]
    #[doc = "  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned."]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorOutOfMemory"]
    #[doc = ""]
    #[doc = "  @see hipSetDeviceFlags, hipHostFree"]
    pub fn hipHostMalloc(
        ptr: *mut *mut ::std::os::raw::c_void,
        size: usize,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Allocates memory that will be automatically managed by AMD HMM."]
    #[doc = ""]
    #[doc = " @param [out] dev_ptr - pointer to allocated device memory"]
    #[doc = " @param [in]  size    - requested allocation size in bytes"]
    #[doc = " @param [in]  flags   - must be either hipMemAttachGlobal or hipMemAttachHost"]
    #[doc = "                        (defaults to hipMemAttachGlobal)"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorMemoryAllocation, #hipErrorNotSupported, #hipErrorInvalidValue"]
    pub fn hipMallocManaged(
        dev_ptr: *mut *mut ::std::os::raw::c_void,
        size: usize,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Prefetches memory to the specified destination device using AMD HMM."]
    #[doc = ""]
    #[doc = " @param [in] dev_ptr  pointer to be prefetched"]
    #[doc = " @param [in] count    size in bytes for prefetching"]
    #[doc = " @param [in] device   destination device to prefetch to"]
    #[doc = " @param [in] stream   stream to enqueue prefetch operation"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipMemPrefetchAsync(
        dev_ptr: *const ::std::os::raw::c_void,
        count: usize,
        device: ::std::os::raw::c_int,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Advise about the usage of a given memory range to AMD HMM."]
    #[doc = ""]
    #[doc = " @param [in] dev_ptr  pointer to memory to set the advice for"]
    #[doc = " @param [in] count    size in bytes of the memory range"]
    #[doc = " @param [in] advice   advice to be applied for the specified memory range"]
    #[doc = " @param [in] device   device to apply the advice for"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipMemAdvise(
        dev_ptr: *const ::std::os::raw::c_void,
        count: usize,
        advice: hipMemoryAdvise,
        device: ::std::os::raw::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Query an attribute of a given memory range in AMD HMM."]
    #[doc = ""]
    #[doc = " @param [in/out] data   a pointer to a memory location where the result of each"]
    #[doc = "                        attribute query will be written to"]
    #[doc = " @param [in] data_size  the size of data"]
    #[doc = " @param [in] attribute  the attribute to query"]
    #[doc = " @param [in] dev_ptr    start of the range to query"]
    #[doc = " @param [in] count      size of the range to query"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipMemRangeGetAttribute(
        data: *mut ::std::os::raw::c_void,
        data_size: usize,
        attribute: hipMemRangeAttribute,
        dev_ptr: *const ::std::os::raw::c_void,
        count: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Query attributes of a given memory range in AMD HMM."]
    #[doc = ""]
    #[doc = " @param [in/out] data     a two-dimensional array containing pointers to memory locations"]
    #[doc = "                          where the result of each attribute query will be written to"]
    #[doc = " @param [in] data_sizes   an array, containing the sizes of each result"]
    #[doc = " @param [in] attributes   the attribute to query"]
    #[doc = " @param [in] num_attributes  an array of attributes to query (numAttributes and the number"]
    #[doc = "                          of attributes in this array should match)"]
    #[doc = " @param [in] dev_ptr      start of the range to query"]
    #[doc = " @param [in] count        size of the range to query"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipMemRangeGetAttributes(
        data: *mut *mut ::std::os::raw::c_void,
        data_sizes: *mut usize,
        attributes: *mut hipMemRangeAttribute,
        num_attributes: usize,
        dev_ptr: *const ::std::os::raw::c_void,
        count: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Attach memory to a stream asynchronously in AMD HMM."]
    #[doc = ""]
    #[doc = " @param [in] stream     - stream in which to enqueue the attach operation"]
    #[doc = " @param [in] dev_ptr    - pointer to memory (must be a pointer to managed memory or"]
    #[doc = "                          to a valid host-accessible region of system-allocated memory)"]
    #[doc = " @param [in] length     - length of memory (defaults to zero)"]
    #[doc = " @param [in] flags      - must be one of cudaMemAttachGlobal, cudaMemAttachHost or"]
    #[doc = "                          cudaMemAttachSingle (defaults to cudaMemAttachSingle)"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipStreamAttachMemAsync(
        stream: hipStream_t,
        dev_ptr: *mut hipDeviceptr_t,
        length: usize,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Allocate device accessible page locked host memory [Deprecated]"]
    #[doc = ""]
    #[doc = "  @param[out] ptr Pointer to the allocated host pinned memory"]
    #[doc = "  @param[in]  size Requested memory size"]
    #[doc = "  @param[in]  flags Type of host memory allocation"]
    #[doc = ""]
    #[doc = "  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned."]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorOutOfMemory"]
    #[doc = ""]
    #[doc = "  @deprecated use hipHostMalloc() instead"]
    pub fn hipHostAlloc(
        ptr: *mut *mut ::std::os::raw::c_void,
        size: usize,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Get Device pointer from Host Pointer allocated through hipHostMalloc"]
    #[doc = ""]
    #[doc = "  @param[out] dstPtr Device Pointer mapped to passed host pointer"]
    #[doc = "  @param[in]  hstPtr Host Pointer allocated through hipHostMalloc"]
    #[doc = "  @param[in]  flags Flags to be passed for extension"]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorOutOfMemory"]
    #[doc = ""]
    #[doc = "  @see hipSetDeviceFlags, hipHostMalloc"]
    pub fn hipHostGetDevicePointer(
        devPtr: *mut *mut ::std::os::raw::c_void,
        hstPtr: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Return flags associated with host pointer"]
    #[doc = ""]
    #[doc = "  @param[out] flagsPtr Memory location to store flags"]
    #[doc = "  @param[in]  hostPtr Host Pointer allocated through hipHostMalloc"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = "  @see hipHostMalloc"]
    pub fn hipHostGetFlags(
        flagsPtr: *mut ::std::os::raw::c_uint,
        hostPtr: *mut ::std::os::raw::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Register host memory so it can be accessed from the current device."]
    #[doc = ""]
    #[doc = "  @param[out] hostPtr Pointer to host memory to be registered."]
    #[doc = "  @param[in] sizeBytes size of the host memory"]
    #[doc = "  @param[in] flags.  See below."]
    #[doc = ""]
    #[doc = "  Flags:"]
    #[doc = "  - #hipHostRegisterDefault   Memory is Mapped and Portable"]
    #[doc = "  - #hipHostRegisterPortable  Memory is considered registered by all contexts.  HIP only supports"]
    #[doc = " one context so this is always assumed true."]
    #[doc = "  - #hipHostRegisterMapped    Map the allocation into the address space for the current device."]
    #[doc = " The device pointer can be obtained with #hipHostGetDevicePointer."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  After registering the memory, use #hipHostGetDevicePointer to obtain the mapped device pointer."]
    #[doc = "  On many systems, the mapped device pointer will have a different value than the mapped host"]
    #[doc = " pointer.  Applications must use the device pointer in device code, and the host pointer in device"]
    #[doc = " code."]
    #[doc = ""]
    #[doc = "  On some systems, registered memory is pinned.  On some systems, registered memory may not be"]
    #[doc = " actually be pinned but uses OS or hardware facilities to all GPU access to the host memory."]
    #[doc = ""]
    #[doc = "  Developers are strongly encouraged to register memory blocks which are aligned to the host"]
    #[doc = " cache-line size. (typically 64-bytes but can be obtains from the CPUID instruction)."]
    #[doc = ""]
    #[doc = "  If registering non-aligned pointers, the application must take care when register pointers from"]
    #[doc = " the same cache line on different devices.  HIP's coarse-grained synchronization model does not"]
    #[doc = " guarantee correct results if different devices write to different parts of the same cache block -"]
    #[doc = " typically one of the writes will \"win\" and overwrite data from the other registered memory"]
    #[doc = " region."]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorOutOfMemory"]
    #[doc = ""]
    #[doc = "  @see hipHostUnregister, hipHostGetFlags, hipHostGetDevicePointer"]
    pub fn hipHostRegister(
        hostPtr: *mut ::std::os::raw::c_void,
        sizeBytes: usize,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Un-register host pointer"]
    #[doc = ""]
    #[doc = "  @param[in] hostPtr Host pointer previously registered with #hipHostRegister"]
    #[doc = "  @return Error code"]
    #[doc = ""]
    #[doc = "  @see hipHostRegister"]
    pub fn hipHostUnregister(hostPtr: *mut ::std::os::raw::c_void) -> hipError_t;
}
extern "C" {
    #[doc = "  Allocates at least width (in bytes) * height bytes of linear memory"]
    #[doc = "  Padding may occur to ensure alighnment requirements are met for the given row"]
    #[doc = "  The change in width size due to padding will be returned in *pitch."]
    #[doc = "  Currently the alignment is set to 128 bytes"]
    #[doc = ""]
    #[doc = "  @param[out] ptr Pointer to the allocated device memory"]
    #[doc = "  @param[out] pitch Pitch for allocation (in bytes)"]
    #[doc = "  @param[in]  width Requested pitched allocation width (in bytes)"]
    #[doc = "  @param[in]  height Requested pitched allocation height"]
    #[doc = ""]
    #[doc = "  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned."]
    #[doc = ""]
    #[doc = "  @return Error code"]
    #[doc = ""]
    #[doc = "  @see hipMalloc, hipFree, hipMallocArray, hipFreeArray, hipHostFree, hipMalloc3D,"]
    #[doc = " hipMalloc3DArray, hipHostMalloc"]
    pub fn hipMallocPitch(
        ptr: *mut *mut ::std::os::raw::c_void,
        pitch: *mut usize,
        width: usize,
        height: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  Allocates at least width (in bytes) * height bytes of linear memory"]
    #[doc = "  Padding may occur to ensure alighnment requirements are met for the given row"]
    #[doc = "  The change in width size due to padding will be returned in *pitch."]
    #[doc = "  Currently the alignment is set to 128 bytes"]
    #[doc = ""]
    #[doc = "  @param[out] dptr Pointer to the allocated device memory"]
    #[doc = "  @param[out] pitch Pitch for allocation (in bytes)"]
    #[doc = "  @param[in]  width Requested pitched allocation width (in bytes)"]
    #[doc = "  @param[in]  height Requested pitched allocation height"]
    #[doc = ""]
    #[doc = "  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned."]
    #[doc = "  The intended usage of pitch is as a separate parameter of the allocation, used to compute addresses within the 2D array."]
    #[doc = "  Given the row and column of an array element of type T, the address is computed as:"]
    #[doc = "  T* pElement = (T*)((char*)BaseAddress + Row * Pitch) + Column;"]
    #[doc = ""]
    #[doc = "  @return Error code"]
    #[doc = ""]
    #[doc = "  @see hipMalloc, hipFree, hipMallocArray, hipFreeArray, hipHostFree, hipMalloc3D,"]
    #[doc = " hipMalloc3DArray, hipHostMalloc"]
    pub fn hipMemAllocPitch(
        dptr: *mut hipDeviceptr_t,
        pitch: *mut usize,
        widthInBytes: usize,
        height: usize,
        elementSizeBytes: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Free memory allocated by the hcc hip memory allocation API."]
    #[doc = "  This API performs an implicit hipDeviceSynchronize() call."]
    #[doc = "  If pointer is NULL, the hip runtime is initialized and hipSuccess is returned."]
    #[doc = ""]
    #[doc = "  @param[in] ptr Pointer to memory to be freed"]
    #[doc = "  @return #hipSuccess"]
    #[doc = "  @return #hipErrorInvalidDevicePointer (if pointer is invalid, including host pointers allocated"]
    #[doc = " with hipHostMalloc)"]
    #[doc = ""]
    #[doc = "  @see hipMalloc, hipMallocPitch, hipMallocArray, hipFreeArray, hipHostFree, hipMalloc3D,"]
    #[doc = " hipMalloc3DArray, hipHostMalloc"]
    pub fn hipFree(ptr: *mut ::std::os::raw::c_void) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Free memory allocated by the hcc hip host memory allocation API.  [Deprecated]"]
    #[doc = ""]
    #[doc = "  @param[in] ptr Pointer to memory to be freed"]
    #[doc = "  @return #hipSuccess,"]
    #[doc = "          #hipErrorInvalidValue (if pointer is invalid, including device pointers allocated with"]
    #[doc = "hipMalloc)"]
    #[doc = ""]
    #[doc = "  @deprecated use hipHostFree() instead"]
    pub fn hipFreeHost(ptr: *mut ::std::os::raw::c_void) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Free memory allocated by the hcc hip host memory allocation API"]
    #[doc = "  This API performs an implicit hipDeviceSynchronize() call."]
    #[doc = "  If pointer is NULL, the hip runtime is initialized and hipSuccess is returned."]
    #[doc = ""]
    #[doc = "  @param[in] ptr Pointer to memory to be freed"]
    #[doc = "  @return #hipSuccess,"]
    #[doc = "          #hipErrorInvalidValue (if pointer is invalid, including device pointers allocated with"]
    #[doc = " hipMalloc)"]
    #[doc = ""]
    #[doc = "  @see hipMalloc, hipMallocPitch, hipFree, hipMallocArray, hipFreeArray, hipMalloc3D,"]
    #[doc = " hipMalloc3DArray, hipHostMalloc"]
    pub fn hipHostFree(ptr: *mut ::std::os::raw::c_void) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copy data from src to dst."]
    #[doc = ""]
    #[doc = "  It supports memory from host to device,"]
    #[doc = "  device to host, device to device and host to host"]
    #[doc = "  The src and dst must not overlap."]
    #[doc = ""]
    #[doc = "  For hipMemcpy, the copy is always performed by the current device (set by hipSetDevice)."]
    #[doc = "  For multi-gpu or peer-to-peer configurations, it is recommended to set the current device to the"]
    #[doc = "  device where the src data is physically located. For optimal peer-to-peer copies, the copy device"]
    #[doc = "  must be able to access the src and dst pointers (by calling hipDeviceEnablePeerAccess with copy"]
    #[doc = "  agent as the current device and src/dest as the peerDevice argument.  if this is not done, the"]
    #[doc = "  hipMemcpy will still work, but will perform the copy using a staging buffer on the host."]
    #[doc = "  Calling hipMemcpy with dst and src pointers that do not match the hipMemcpyKind results in"]
    #[doc = "  undefined behavior."]
    #[doc = ""]
    #[doc = "  @param[out]  dst Data being copy to"]
    #[doc = "  @param[in]  src Data being copy from"]
    #[doc = "  @param[in]  sizeBytes Data size in bytes"]
    #[doc = "  @param[in]  copyType Memory copy type"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree, #hipErrorUnknowni"]
    #[doc = ""]
    #[doc = "  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,"]
    #[doc = " hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,"]
    #[doc = " hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,"]
    #[doc = " hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,"]
    #[doc = " hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,"]
    #[doc = " hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpy(
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMemcpyWithStream(
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copy data from Host to Device"]
    #[doc = ""]
    #[doc = "  @param[out]  dst Data being copy to"]
    #[doc = "  @param[in]   src Data being copy from"]
    #[doc = "  @param[in]   sizeBytes Data size in bytes"]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorDeInitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,"]
    #[doc = " #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = "  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,"]
    #[doc = " hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,"]
    #[doc = " hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,"]
    #[doc = " hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,"]
    #[doc = " hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,"]
    #[doc = " hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyHtoD(
        dst: hipDeviceptr_t,
        src: *mut ::std::os::raw::c_void,
        sizeBytes: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copy data from Device to Host"]
    #[doc = ""]
    #[doc = "  @param[out]  dst Data being copy to"]
    #[doc = "  @param[in]   src Data being copy from"]
    #[doc = "  @param[in]   sizeBytes Data size in bytes"]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorDeInitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,"]
    #[doc = " #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = "  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,"]
    #[doc = " hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,"]
    #[doc = " hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,"]
    #[doc = " hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,"]
    #[doc = " hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,"]
    #[doc = " hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyDtoH(
        dst: *mut ::std::os::raw::c_void,
        src: hipDeviceptr_t,
        sizeBytes: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copy data from Device to Device"]
    #[doc = ""]
    #[doc = "  @param[out]  dst Data being copy to"]
    #[doc = "  @param[in]   src Data being copy from"]
    #[doc = "  @param[in]   sizeBytes Data size in bytes"]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorDeInitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,"]
    #[doc = " #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = "  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,"]
    #[doc = " hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,"]
    #[doc = " hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,"]
    #[doc = " hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,"]
    #[doc = " hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,"]
    #[doc = " hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyDtoD(dst: hipDeviceptr_t, src: hipDeviceptr_t, sizeBytes: usize) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copy data from Host to Device asynchronously"]
    #[doc = ""]
    #[doc = "  @param[out]  dst Data being copy to"]
    #[doc = "  @param[in]   src Data being copy from"]
    #[doc = "  @param[in]   sizeBytes Data size in bytes"]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorDeInitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,"]
    #[doc = " #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = "  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,"]
    #[doc = " hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,"]
    #[doc = " hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,"]
    #[doc = " hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,"]
    #[doc = " hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,"]
    #[doc = " hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyHtoDAsync(
        dst: hipDeviceptr_t,
        src: *mut ::std::os::raw::c_void,
        sizeBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copy data from Device to Host asynchronously"]
    #[doc = ""]
    #[doc = "  @param[out]  dst Data being copy to"]
    #[doc = "  @param[in]   src Data being copy from"]
    #[doc = "  @param[in]   sizeBytes Data size in bytes"]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorDeInitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,"]
    #[doc = " #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = "  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,"]
    #[doc = " hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,"]
    #[doc = " hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,"]
    #[doc = " hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,"]
    #[doc = " hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,"]
    #[doc = " hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyDtoHAsync(
        dst: *mut ::std::os::raw::c_void,
        src: hipDeviceptr_t,
        sizeBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copy data from Device to Device asynchronously"]
    #[doc = ""]
    #[doc = "  @param[out]  dst Data being copy to"]
    #[doc = "  @param[in]   src Data being copy from"]
    #[doc = "  @param[in]   sizeBytes Data size in bytes"]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorDeInitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,"]
    #[doc = " #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = "  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,"]
    #[doc = " hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,"]
    #[doc = " hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,"]
    #[doc = " hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,"]
    #[doc = " hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,"]
    #[doc = " hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyDtoDAsync(
        dst: hipDeviceptr_t,
        src: hipDeviceptr_t,
        sizeBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipModuleGetGlobal(
        dptr: *mut hipDeviceptr_t,
        bytes: *mut usize,
        hmod: hipModule_t,
        name: *const ::std::os::raw::c_char,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipGetSymbolAddress(
        devPtr: *mut *mut ::std::os::raw::c_void,
        symbol: *const ::std::os::raw::c_void,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipGetSymbolSize(size: *mut usize, symbol: *const ::std::os::raw::c_void) -> hipError_t;
}
extern "C" {
    pub fn hipMemcpyToSymbol(
        symbol: *const ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        offset: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMemcpyToSymbolAsync(
        symbol: *const ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        offset: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMemcpyFromSymbol(
        dst: *mut ::std::os::raw::c_void,
        symbol: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        offset: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMemcpyFromSymbolAsync(
        dst: *mut ::std::os::raw::c_void,
        symbol: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        offset: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copy data from src to dst asynchronously."]
    #[doc = ""]
    #[doc = "  @warning If host or dest are not pinned, the memory copy will be performed synchronously.  For"]
    #[doc = " best performance, use hipHostMalloc to allocate host memory that is transferred asynchronously."]
    #[doc = ""]
    #[doc = "  @warning on HCC hipMemcpyAsync does not support overlapped H2D and D2H copies."]
    #[doc = "  For hipMemcpy, the copy is always performed by the device associated with the specified stream."]
    #[doc = ""]
    #[doc = "  For multi-gpu or peer-to-peer configurations, it is recommended to use a stream which is a"]
    #[doc = " attached to the device where the src data is physically located. For optimal peer-to-peer copies,"]
    #[doc = " the copy device must be able to access the src and dst pointers (by calling"]
    #[doc = " hipDeviceEnablePeerAccess with copy agent as the current device and src/dest as the peerDevice"]
    #[doc = " argument.  if this is not done, the hipMemcpy will still work, but will perform the copy using a"]
    #[doc = " staging buffer on the host."]
    #[doc = ""]
    #[doc = "  @param[out] dst Data being copy to"]
    #[doc = "  @param[in]  src Data being copy from"]
    #[doc = "  @param[in]  sizeBytes Data size in bytes"]
    #[doc = "  @param[in]  accelerator_view Accelerator view which the copy is being enqueued"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree, #hipErrorUnknown"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpy2D, hipMemcpyToArray, hipMemcpy2DToArray, hipMemcpyFromArray,"]
    #[doc = " hipMemcpy2DFromArray, hipMemcpyArrayToArray, hipMemcpy2DArrayToArray, hipMemcpyToSymbol,"]
    #[doc = " hipMemcpyFromSymbol, hipMemcpy2DAsync, hipMemcpyToArrayAsync, hipMemcpy2DToArrayAsync,"]
    #[doc = " hipMemcpyFromArrayAsync, hipMemcpy2DFromArrayAsync, hipMemcpyToSymbolAsync,"]
    #[doc = " hipMemcpyFromSymbolAsync"]
    pub fn hipMemcpyAsync(
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant"]
    #[doc = " byte value value."]
    #[doc = ""]
    #[doc = "  @param[out] dst Data being filled"]
    #[doc = "  @param[in]  constant value to be set"]
    #[doc = "  @param[in]  sizeBytes Data size in bytes"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    pub fn hipMemset(
        dst: *mut ::std::os::raw::c_void,
        value: ::std::os::raw::c_int,
        sizeBytes: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant"]
    #[doc = " byte value value."]
    #[doc = ""]
    #[doc = "  @param[out] dst Data ptr to be filled"]
    #[doc = "  @param[in]  constant value to be set"]
    #[doc = "  @param[in]  number of values to be set"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    pub fn hipMemsetD8(
        dest: hipDeviceptr_t,
        value: ::std::os::raw::c_uchar,
        count: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant"]
    #[doc = " byte value value."]
    #[doc = ""]
    #[doc = " hipMemsetD8Async() is asynchronous with respect to the host, so the call may return before the"]
    #[doc = " memset is complete. The operation can optionally be associated to a stream by passing a non-zero"]
    #[doc = " stream argument. If stream is non-zero, the operation may overlap with operations in other"]
    #[doc = " streams."]
    #[doc = ""]
    #[doc = "  @param[out] dst Data ptr to be filled"]
    #[doc = "  @param[in]  constant value to be set"]
    #[doc = "  @param[in]  number of values to be set"]
    #[doc = "  @param[in]  stream - Stream identifier"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    pub fn hipMemsetD8Async(
        dest: hipDeviceptr_t,
        value: ::std::os::raw::c_uchar,
        count: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant"]
    #[doc = " short value value."]
    #[doc = ""]
    #[doc = "  @param[out] dst Data ptr to be filled"]
    #[doc = "  @param[in]  constant value to be set"]
    #[doc = "  @param[in]  number of values to be set"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    pub fn hipMemsetD16(
        dest: hipDeviceptr_t,
        value: ::std::os::raw::c_ushort,
        count: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant"]
    #[doc = " short value value."]
    #[doc = ""]
    #[doc = " hipMemsetD16Async() is asynchronous with respect to the host, so the call may return before the"]
    #[doc = " memset is complete. The operation can optionally be associated to a stream by passing a non-zero"]
    #[doc = " stream argument. If stream is non-zero, the operation may overlap with operations in other"]
    #[doc = " streams."]
    #[doc = ""]
    #[doc = "  @param[out] dst Data ptr to be filled"]
    #[doc = "  @param[in]  constant value to be set"]
    #[doc = "  @param[in]  number of values to be set"]
    #[doc = "  @param[in]  stream - Stream identifier"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    pub fn hipMemsetD16Async(
        dest: hipDeviceptr_t,
        value: ::std::os::raw::c_ushort,
        count: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the memory area pointed to by dest with the constant integer"]
    #[doc = " value for specified number of times."]
    #[doc = ""]
    #[doc = "  @param[out] dst Data being filled"]
    #[doc = "  @param[in]  constant value to be set"]
    #[doc = "  @param[in]  number of values to be set"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    pub fn hipMemsetD32(
        dest: hipDeviceptr_t,
        value: ::std::os::raw::c_int,
        count: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the first sizeBytes bytes of the memory area pointed to by dev with the constant"]
    #[doc = " byte value value."]
    #[doc = ""]
    #[doc = "  hipMemsetAsync() is asynchronous with respect to the host, so the call may return before the"]
    #[doc = " memset is complete. The operation can optionally be associated to a stream by passing a non-zero"]
    #[doc = " stream argument. If stream is non-zero, the operation may overlap with operations in other"]
    #[doc = " streams."]
    #[doc = ""]
    #[doc = "  @param[out] dst Pointer to device memory"]
    #[doc = "  @param[in]  value - Value to set for each byte of specified memory"]
    #[doc = "  @param[in]  sizeBytes - Size in bytes to set"]
    #[doc = "  @param[in]  stream - Stream identifier"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree"]
    pub fn hipMemsetAsync(
        dst: *mut ::std::os::raw::c_void,
        value: ::std::os::raw::c_int,
        sizeBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the memory area pointed to by dev with the constant integer"]
    #[doc = " value for specified number of times."]
    #[doc = ""]
    #[doc = "  hipMemsetD32Async() is asynchronous with respect to the host, so the call may return before the"]
    #[doc = " memset is complete. The operation can optionally be associated to a stream by passing a non-zero"]
    #[doc = " stream argument. If stream is non-zero, the operation may overlap with operations in other"]
    #[doc = " streams."]
    #[doc = ""]
    #[doc = "  @param[out] dst Pointer to device memory"]
    #[doc = "  @param[in]  value - Value to set for each byte of specified memory"]
    #[doc = "  @param[in]  count - number of values to be set"]
    #[doc = "  @param[in]  stream - Stream identifier"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree"]
    pub fn hipMemsetD32Async(
        dst: hipDeviceptr_t,
        value: ::std::os::raw::c_int,
        count: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the memory area pointed to by dst with the constant value."]
    #[doc = ""]
    #[doc = "  @param[out] dst Pointer to device memory"]
    #[doc = "  @param[in]  pitch - data size in bytes"]
    #[doc = "  @param[in]  value - constant value to be set"]
    #[doc = "  @param[in]  width"]
    #[doc = "  @param[in]  height"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree"]
    pub fn hipMemset2D(
        dst: *mut ::std::os::raw::c_void,
        pitch: usize,
        value: ::std::os::raw::c_int,
        width: usize,
        height: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills asynchronously the memory area pointed to by dst with the constant value."]
    #[doc = ""]
    #[doc = "  @param[in]  dst Pointer to device memory"]
    #[doc = "  @param[in]  pitch - data size in bytes"]
    #[doc = "  @param[in]  value - constant value to be set"]
    #[doc = "  @param[in]  width"]
    #[doc = "  @param[in]  height"]
    #[doc = "  @param[in]  stream"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree"]
    pub fn hipMemset2DAsync(
        dst: *mut ::std::os::raw::c_void,
        pitch: usize,
        value: ::std::os::raw::c_int,
        width: usize,
        height: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills synchronously the memory area pointed to by pitchedDevPtr with the constant value."]
    #[doc = ""]
    #[doc = "  @param[in] pitchedDevPtr"]
    #[doc = "  @param[in]  value - constant value to be set"]
    #[doc = "  @param[in]  extent"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree"]
    pub fn hipMemset3D(
        pitchedDevPtr: hipPitchedPtr,
        value: ::std::os::raw::c_int,
        extent: hipExtent,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills asynchronously the memory area pointed to by pitchedDevPtr with the constant value."]
    #[doc = ""]
    #[doc = "  @param[in] pitchedDevPtr"]
    #[doc = "  @param[in]  value - constant value to be set"]
    #[doc = "  @param[in]  extent"]
    #[doc = "  @param[in]  stream"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree"]
    pub fn hipMemset3DAsync(
        pitchedDevPtr: hipPitchedPtr,
        value: ::std::os::raw::c_int,
        extent: hipExtent,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Query memory info."]
    #[doc = " Return snapshot of free memory, and total allocatable memory on the device."]
    #[doc = ""]
    #[doc = " Returns in *free a snapshot of the current free memory."]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue"]
    #[doc = " @warning On HCC, the free memory only accounts for memory allocated by this process and may be"]
    #[doc = "optimistic."]
    pub fn hipMemGetInfo(free: *mut usize, total: *mut usize) -> hipError_t;
}
extern "C" {
    pub fn hipMemPtrGetInfo(ptr: *mut ::std::os::raw::c_void, size: *mut usize) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Allocate an array on the device."]
    #[doc = ""]
    #[doc = "  @param[out]  array  Pointer to allocated array in device memory"]
    #[doc = "  @param[in]   desc   Requested channel format"]
    #[doc = "  @param[in]   width  Requested array allocation width"]
    #[doc = "  @param[in]   height Requested array allocation height"]
    #[doc = "  @param[in]   flags  Requested properties of allocated array"]
    #[doc = "  @return      #hipSuccess, #hipErrorOutOfMemory"]
    #[doc = ""]
    #[doc = "  @see hipMalloc, hipMallocPitch, hipFree, hipFreeArray, hipHostMalloc, hipHostFree"]
    pub fn hipMallocArray(
        array: *mut *mut hipArray,
        desc: *const hipChannelFormatDesc,
        width: usize,
        height: usize,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipArrayCreate(
        pHandle: *mut *mut hipArray,
        pAllocateArray: *const HIP_ARRAY_DESCRIPTOR,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipArrayDestroy(array: *mut hipArray) -> hipError_t;
}
extern "C" {
    pub fn hipArray3DCreate(
        array: *mut *mut hipArray,
        pAllocateArray: *const HIP_ARRAY3D_DESCRIPTOR,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMalloc3D(pitchedDevPtr: *mut hipPitchedPtr, extent: hipExtent) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Frees an array on the device."]
    #[doc = ""]
    #[doc = "  @param[in]  array  Pointer to array to free"]
    #[doc = "  @return     #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    #[doc = ""]
    #[doc = "  @see hipMalloc, hipMallocPitch, hipFree, hipMallocArray, hipHostMalloc, hipHostFree"]
    pub fn hipFreeArray(array: *mut hipArray) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Frees a mipmapped array on the device"]
    #[doc = ""]
    #[doc = " @param[in] mipmappedArray - Pointer to mipmapped array to free"]
    #[doc = ""]
    #[doc = " @return #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipFreeMipmappedArray(mipmappedArray: hipMipmappedArray_t) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Allocate an array on the device."]
    #[doc = ""]
    #[doc = "  @param[out]  array  Pointer to allocated array in device memory"]
    #[doc = "  @param[in]   desc   Requested channel format"]
    #[doc = "  @param[in]   extent Requested array allocation width, height and depth"]
    #[doc = "  @param[in]   flags  Requested properties of allocated array"]
    #[doc = "  @return      #hipSuccess, #hipErrorOutOfMemory"]
    #[doc = ""]
    #[doc = "  @see hipMalloc, hipMallocPitch, hipFree, hipFreeArray, hipHostMalloc, hipHostFree"]
    pub fn hipMalloc3DArray(
        array: *mut *mut hipArray,
        desc: *const hipChannelFormatDesc,
        extent: hipExtent,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Allocate a mipmapped array on the device"]
    #[doc = ""]
    #[doc = " @param[out] mipmappedArray  - Pointer to allocated mipmapped array in device memory"]
    #[doc = " @param[in]  desc            - Requested channel format"]
    #[doc = " @param[in]  extent          - Requested allocation size (width field in elements)"]
    #[doc = " @param[in]  numLevels       - Number of mipmap levels to allocate"]
    #[doc = " @param[in]  flags           - Flags for extensions"]
    #[doc = ""]
    #[doc = " @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryAllocation"]
    pub fn hipMallocMipmappedArray(
        mipmappedArray: *mut hipMipmappedArray_t,
        desc: *const hipChannelFormatDesc,
        extent: hipExtent,
        numLevels: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets a mipmap level of a HIP mipmapped array"]
    #[doc = ""]
    #[doc = " @param[out] levelArray     - Returned mipmap level HIP array"]
    #[doc = " @param[in]  mipmappedArray - HIP mipmapped array"]
    #[doc = " @param[in]  level          - Mipmap level"]
    #[doc = ""]
    #[doc = " @return #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipGetMipmappedArrayLevel(
        levelArray: *mut hipArray_t,
        mipmappedArray: hipMipmappedArray_const_t,
        level: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device."]
    #[doc = ""]
    #[doc = "  @param[in]   dst    Destination memory address"]
    #[doc = "  @param[in]   dpitch Pitch of destination memory"]
    #[doc = "  @param[in]   src    Source memory address"]
    #[doc = "  @param[in]   spitch Pitch of source memory"]
    #[doc = "  @param[in]   width  Width of matrix transfer (columns in bytes)"]
    #[doc = "  @param[in]   height Height of matrix transfer (rows)"]
    #[doc = "  @param[in]   kind   Type of transfer"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = " #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpyToArray, hipMemcpy2DToArray, hipMemcpyFromArray, hipMemcpyToSymbol,"]
    #[doc = " hipMemcpyAsync"]
    pub fn hipMemcpy2D(
        dst: *mut ::std::os::raw::c_void,
        dpitch: usize,
        src: *const ::std::os::raw::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies memory for 2D arrays."]
    #[doc = "  @param[in]   pCopy Parameters for the memory copy"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = "  #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpy2D, hipMemcpyToArray, hipMemcpy2DToArray, hipMemcpyFromArray,"]
    #[doc = " hipMemcpyToSymbol, hipMemcpyAsync"]
    pub fn hipMemcpyParam2D(pCopy: *const hip_Memcpy2D) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies memory for 2D arrays."]
    #[doc = "  @param[in]   pCopy Parameters for the memory copy"]
    #[doc = "  @param[in]   stream Stream to use"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = " #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpy2D, hipMemcpyToArray, hipMemcpy2DToArray, hipMemcpyFromArray,"]
    #[doc = " hipMemcpyToSymbol, hipMemcpyAsync"]
    pub fn hipMemcpyParam2DAsync(pCopy: *const hip_Memcpy2D, stream: hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device."]
    #[doc = ""]
    #[doc = "  @param[in]   dst    Destination memory address"]
    #[doc = "  @param[in]   dpitch Pitch of destination memory"]
    #[doc = "  @param[in]   src    Source memory address"]
    #[doc = "  @param[in]   spitch Pitch of source memory"]
    #[doc = "  @param[in]   width  Width of matrix transfer (columns in bytes)"]
    #[doc = "  @param[in]   height Height of matrix transfer (rows)"]
    #[doc = "  @param[in]   kind   Type of transfer"]
    #[doc = "  @param[in]   stream Stream to use"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = " #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpyToArray, hipMemcpy2DToArray, hipMemcpyFromArray, hipMemcpyToSymbol,"]
    #[doc = " hipMemcpyAsync"]
    pub fn hipMemcpy2DAsync(
        dst: *mut ::std::os::raw::c_void,
        dpitch: usize,
        src: *const ::std::os::raw::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device."]
    #[doc = ""]
    #[doc = "  @param[in]   dst     Destination memory address"]
    #[doc = "  @param[in]   wOffset Destination starting X offset"]
    #[doc = "  @param[in]   hOffset Destination starting Y offset"]
    #[doc = "  @param[in]   src     Source memory address"]
    #[doc = "  @param[in]   spitch  Pitch of source memory"]
    #[doc = "  @param[in]   width   Width of matrix transfer (columns in bytes)"]
    #[doc = "  @param[in]   height  Height of matrix transfer (rows)"]
    #[doc = "  @param[in]   kind    Type of transfer"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = " #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpyToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,"]
    #[doc = " hipMemcpyAsync"]
    pub fn hipMemcpy2DToArray(
        dst: *mut hipArray,
        wOffset: usize,
        hOffset: usize,
        src: *const ::std::os::raw::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device."]
    #[doc = ""]
    #[doc = "  @param[in]   dst     Destination memory address"]
    #[doc = "  @param[in]   wOffset Destination starting X offset"]
    #[doc = "  @param[in]   hOffset Destination starting Y offset"]
    #[doc = "  @param[in]   src     Source memory address"]
    #[doc = "  @param[in]   spitch  Pitch of source memory"]
    #[doc = "  @param[in]   width   Width of matrix transfer (columns in bytes)"]
    #[doc = "  @param[in]   height  Height of matrix transfer (rows)"]
    #[doc = "  @param[in]   kind    Type of transfer"]
    #[doc = "  @param[in]   stream    Accelerator view which the copy is being enqueued"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = " #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpyToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,"]
    #[doc = " hipMemcpyAsync"]
    pub fn hipMemcpy2DToArrayAsync(
        dst: *mut hipArray,
        wOffset: usize,
        hOffset: usize,
        src: *const ::std::os::raw::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device."]
    #[doc = ""]
    #[doc = "  @param[in]   dst     Destination memory address"]
    #[doc = "  @param[in]   wOffset Destination starting X offset"]
    #[doc = "  @param[in]   hOffset Destination starting Y offset"]
    #[doc = "  @param[in]   src     Source memory address"]
    #[doc = "  @param[in]   count   size in bytes to copy"]
    #[doc = "  @param[in]   kind    Type of transfer"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = " #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,"]
    #[doc = " hipMemcpyAsync"]
    pub fn hipMemcpyToArray(
        dst: *mut hipArray,
        wOffset: usize,
        hOffset: usize,
        src: *const ::std::os::raw::c_void,
        count: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device."]
    #[doc = ""]
    #[doc = "  @param[in]   dst       Destination memory address"]
    #[doc = "  @param[in]   srcArray  Source memory address"]
    #[doc = "  @param[in]   woffset   Source starting X offset"]
    #[doc = "  @param[in]   hOffset   Source starting Y offset"]
    #[doc = "  @param[in]   count     Size in bytes to copy"]
    #[doc = "  @param[in]   kind      Type of transfer"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = " #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,"]
    #[doc = " hipMemcpyAsync"]
    pub fn hipMemcpyFromArray(
        dst: *mut ::std::os::raw::c_void,
        srcArray: hipArray_const_t,
        wOffset: usize,
        hOffset: usize,
        count: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device."]
    #[doc = ""]
    #[doc = "  @param[in]   dst       Destination memory address"]
    #[doc = "  @param[in]   dpitch    Pitch of destination memory"]
    #[doc = "  @param[in]   src       Source memory address"]
    #[doc = "  @param[in]   wOffset   Source starting X offset"]
    #[doc = "  @param[in]   hOffset   Source starting Y offset"]
    #[doc = "  @param[in]   width     Width of matrix transfer (columns in bytes)"]
    #[doc = "  @param[in]   height    Height of matrix transfer (rows)"]
    #[doc = "  @param[in]   kind      Type of transfer"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = " #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,"]
    #[doc = " hipMemcpyAsync"]
    pub fn hipMemcpy2DFromArray(
        dst: *mut ::std::os::raw::c_void,
        dpitch: usize,
        src: hipArray_const_t,
        wOffset: usize,
        hOffset: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device asynchronously."]
    #[doc = ""]
    #[doc = "  @param[in]   dst       Destination memory address"]
    #[doc = "  @param[in]   dpitch    Pitch of destination memory"]
    #[doc = "  @param[in]   src       Source memory address"]
    #[doc = "  @param[in]   wOffset   Source starting X offset"]
    #[doc = "  @param[in]   hOffset   Source starting Y offset"]
    #[doc = "  @param[in]   width     Width of matrix transfer (columns in bytes)"]
    #[doc = "  @param[in]   height    Height of matrix transfer (rows)"]
    #[doc = "  @param[in]   kind      Type of transfer"]
    #[doc = "  @param[in]   stream    Accelerator view which the copy is being enqueued"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = " #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,"]
    #[doc = " hipMemcpyAsync"]
    pub fn hipMemcpy2DFromArrayAsync(
        dst: *mut ::std::os::raw::c_void,
        dpitch: usize,
        src: hipArray_const_t,
        wOffset: usize,
        hOffset: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device."]
    #[doc = ""]
    #[doc = "  @param[in]   dst       Destination memory address"]
    #[doc = "  @param[in]   srcArray  Source array"]
    #[doc = "  @param[in]   srcoffset Offset in bytes of source array"]
    #[doc = "  @param[in]   count     Size of memory copy in bytes"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = " #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,"]
    #[doc = " hipMemcpyAsync"]
    pub fn hipMemcpyAtoH(
        dst: *mut ::std::os::raw::c_void,
        srcArray: *mut hipArray,
        srcOffset: usize,
        count: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device."]
    #[doc = ""]
    #[doc = "  @param[in]   dstArray   Destination memory address"]
    #[doc = "  @param[in]   dstOffset  Offset in bytes of destination array"]
    #[doc = "  @param[in]   srcHost    Source host pointer"]
    #[doc = "  @param[in]   count      Size of memory copy in bytes"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = " #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,"]
    #[doc = " hipMemcpyAsync"]
    pub fn hipMemcpyHtoA(
        dstArray: *mut hipArray,
        dstOffset: usize,
        srcHost: *const ::std::os::raw::c_void,
        count: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device."]
    #[doc = ""]
    #[doc = "  @param[in]   p   3D memory copy parameters"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = " #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,"]
    #[doc = " hipMemcpyAsync"]
    pub fn hipMemcpy3D(p: *const hipMemcpy3DParms) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device asynchronously."]
    #[doc = ""]
    #[doc = "  @param[in]   p        3D memory copy parameters"]
    #[doc = "  @param[in]   stream   Stream to use"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = " #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,"]
    #[doc = " hipMemcpyAsync"]
    pub fn hipMemcpy3DAsync(p: *const hipMemcpy3DParms, stream: hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device."]
    #[doc = ""]
    #[doc = "  @param[in]   pCopy   3D memory copy parameters"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = "  #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,"]
    #[doc = " hipMemcpyAsync"]
    pub fn hipDrvMemcpy3D(pCopy: *const HIP_MEMCPY3D) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device asynchronously."]
    #[doc = ""]
    #[doc = "  @param[in]   pCopy    3D memory copy parameters"]
    #[doc = "  @param[in]   stream   Stream to use"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = "  #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,"]
    #[doc = " hipMemcpyAsync"]
    pub fn hipDrvMemcpy3DAsync(pCopy: *const HIP_MEMCPY3D, stream: hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Determine if a device can access a peer's memory."]
    #[doc = ""]
    #[doc = " @param [out] canAccessPeer Returns the peer access capability (0 or 1)"]
    #[doc = " @param [in] device - device from where memory may be accessed."]
    #[doc = " @param [in] peerDevice - device where memory is physically located"]
    #[doc = ""]
    #[doc = " Returns \"1\" in @p canAccessPeer if the specified @p device is capable"]
    #[doc = " of directly accessing memory physically located on peerDevice , or \"0\" if not."]
    #[doc = ""]
    #[doc = " Returns \"0\" in @p canAccessPeer if deviceId == peerDeviceId, and both are valid devices : a"]
    #[doc = " device is not a peer of itself."]
    #[doc = ""]
    #[doc = " @returns #hipSuccess,"]
    #[doc = " @returns #hipErrorInvalidDevice if deviceId or peerDeviceId are not valid devices"]
    pub fn hipDeviceCanAccessPeer(
        canAccessPeer: *mut ::std::os::raw::c_int,
        deviceId: ::std::os::raw::c_int,
        peerDeviceId: ::std::os::raw::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Enable direct access from current device's virtual address space to memory allocations"]
    #[doc = " physically located on a peer device."]
    #[doc = ""]
    #[doc = " Memory which already allocated on peer device will be mapped into the address space of the"]
    #[doc = " current device.  In addition, all future memory allocations on peerDeviceId will be mapped into"]
    #[doc = " the address space of the current device when the memory is allocated. The peer memory remains"]
    #[doc = " accessible from the current device until a call to hipDeviceDisablePeerAccess or hipDeviceReset."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param [in] peerDeviceId"]
    #[doc = " @param [in] flags"]
    #[doc = ""]
    #[doc = " Returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue,"]
    #[doc = " @returns #hipErrorPeerAccessAlreadyEnabled if peer access is already enabled for this device."]
    pub fn hipDeviceEnablePeerAccess(
        peerDeviceId: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Disable direct access from current device's virtual address space to memory allocations"]
    #[doc = " physically located on a peer device."]
    #[doc = ""]
    #[doc = " Returns hipErrorPeerAccessNotEnabled if direct access to memory on peerDevice has not yet been"]
    #[doc = " enabled from the current device."]
    #[doc = ""]
    #[doc = " @param [in] peerDeviceId"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorPeerAccessNotEnabled"]
    pub fn hipDeviceDisablePeerAccess(peerDeviceId: ::std::os::raw::c_int) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get information on memory allocations."]
    #[doc = ""]
    #[doc = " @param [out] pbase - BAse pointer address"]
    #[doc = " @param [out] psize - Size of allocation"]
    #[doc = " @param [in]  dptr- Device Pointer"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidDevicePointer"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipMemGetAddressRange(
        pbase: *mut hipDeviceptr_t,
        psize: *mut usize,
        dptr: hipDeviceptr_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Copies memory from one device to memory on another device."]
    #[doc = ""]
    #[doc = " @param [out] dst - Destination device pointer."]
    #[doc = " @param [in] dstDeviceId - Destination device"]
    #[doc = " @param [in] src - Source device pointer"]
    #[doc = " @param [in] srcDeviceId - Source device"]
    #[doc = " @param [in] sizeBytes - Size of memory copy in bytes"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidDevice"]
    pub fn hipMemcpyPeer(
        dst: *mut ::std::os::raw::c_void,
        dstDeviceId: ::std::os::raw::c_int,
        src: *const ::std::os::raw::c_void,
        srcDeviceId: ::std::os::raw::c_int,
        sizeBytes: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Copies memory from one device to memory on another device."]
    #[doc = ""]
    #[doc = " @param [out] dst - Destination device pointer."]
    #[doc = " @param [in] dstDevice - Destination device"]
    #[doc = " @param [in] src - Source device pointer"]
    #[doc = " @param [in] srcDevice - Source device"]
    #[doc = " @param [in] sizeBytes - Size of memory copy in bytes"]
    #[doc = " @param [in] stream - Stream identifier"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidDevice"]
    pub fn hipMemcpyPeerAsync(
        dst: *mut ::std::os::raw::c_void,
        dstDeviceId: ::std::os::raw::c_int,
        src: *const ::std::os::raw::c_void,
        srcDevice: ::std::os::raw::c_int,
        sizeBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Create a context and set it as current/ default context"]
    #[doc = ""]
    #[doc = " @param [out] ctx"]
    #[doc = " @param [in] flags"]
    #[doc = " @param [in] associated device handle"]
    #[doc = ""]
    #[doc = " @return #hipSuccess"]
    #[doc = ""]
    #[doc = " @see hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent, hipCtxPushCurrent,"]
    #[doc = " hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipCtxCreate(
        ctx: *mut hipCtx_t,
        flags: ::std::os::raw::c_uint,
        device: hipDevice_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Destroy a HIP context."]
    #[doc = ""]
    #[doc = " @param [in] ctx Context to destroy"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,hipCtxSetCurrent,"]
    #[doc = " hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize , hipCtxGetDevice"]
    pub fn hipCtxDestroy(ctx: hipCtx_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Pop the current/default context and return the popped context."]
    #[doc = ""]
    #[doc = " @param [out] ctx"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidContext"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxSetCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipCtxPopCurrent(ctx: *mut hipCtx_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Push the context to be set as current/ default context"]
    #[doc = ""]
    #[doc = " @param [in] ctx"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidContext"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize , hipCtxGetDevice"]
    pub fn hipCtxPushCurrent(ctx: hipCtx_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set the passed context as current/default"]
    #[doc = ""]
    #[doc = " @param [in] ctx"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidContext"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize , hipCtxGetDevice"]
    pub fn hipCtxSetCurrent(ctx: hipCtx_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get the handle of the current/ default context"]
    #[doc = ""]
    #[doc = " @param [out] ctx"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidContext"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetDevice, hipCtxGetFlags, hipCtxPopCurrent,"]
    #[doc = " hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipCtxGetCurrent(ctx: *mut hipCtx_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get the handle of the device associated with current/default context"]
    #[doc = ""]
    #[doc = " @param [out] device"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidContext"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize"]
    pub fn hipCtxGetDevice(device: *mut hipDevice_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns the approximate HIP api version."]
    #[doc = ""]
    #[doc = " @param [in]  ctx Context to check"]
    #[doc = " @param [out] apiVersion"]
    #[doc = ""]
    #[doc = " @return #hipSuccess"]
    #[doc = ""]
    #[doc = " @warning The HIP feature set does not correspond to an exact CUDA SDK api revision."]
    #[doc = " This function always set *apiVersion to 4 as an approximation though HIP supports"]
    #[doc = " some features which were introduced in later CUDA SDK revisions."]
    #[doc = " HIP apps code should not rely on the api revision number here and should"]
    #[doc = " use arch feature flags to test device capabilities or conditional compilation."]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetDevice, hipCtxGetFlags, hipCtxPopCurrent,"]
    #[doc = " hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipCtxGetApiVersion(ctx: hipCtx_t, apiVersion: *mut ::std::os::raw::c_int)
        -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set Cache configuration for a specific function"]
    #[doc = ""]
    #[doc = " @param [out] cacheConfiguration"]
    #[doc = ""]
    #[doc = " @return #hipSuccess"]
    #[doc = ""]
    #[doc = " @warning AMD devices and some Nvidia GPUS do not support reconfigurable cache.  This hint is"]
    #[doc = " ignored on those architectures."]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipCtxGetCacheConfig(cacheConfig: *mut hipFuncCache_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set L1/Shared cache partition."]
    #[doc = ""]
    #[doc = " @param [in] cacheConfiguration"]
    #[doc = ""]
    #[doc = " @return #hipSuccess"]
    #[doc = ""]
    #[doc = " @warning AMD devices and some Nvidia GPUS do not support reconfigurable cache.  This hint is"]
    #[doc = " ignored on those architectures."]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipCtxSetCacheConfig(cacheConfig: hipFuncCache_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set Shared memory bank configuration."]
    #[doc = ""]
    #[doc = " @param [in] sharedMemoryConfiguration"]
    #[doc = ""]
    #[doc = " @return #hipSuccess"]
    #[doc = ""]
    #[doc = " @warning AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is"]
    #[doc = " ignored on those architectures."]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipCtxSetSharedMemConfig(config: hipSharedMemConfig) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get Shared memory bank configuration."]
    #[doc = ""]
    #[doc = " @param [out] sharedMemoryConfiguration"]
    #[doc = ""]
    #[doc = " @return #hipSuccess"]
    #[doc = ""]
    #[doc = " @warning AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is"]
    #[doc = " ignored on those architectures."]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipCtxGetSharedMemConfig(pConfig: *mut hipSharedMemConfig) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Blocks until the default context has completed all preceding requested tasks."]
    #[doc = ""]
    #[doc = " @return #hipSuccess"]
    #[doc = ""]
    #[doc = " @warning This function waits for all streams on the default context to complete execution, and"]
    #[doc = " then returns."]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxGetDevice"]
    pub fn hipCtxSynchronize() -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return flags used for creating default context."]
    #[doc = ""]
    #[doc = " @param [out] flags"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxPopCurrent, hipCtxGetCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipCtxGetFlags(flags: *mut ::std::os::raw::c_uint) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Enables direct access to memory allocations in a peer context."]
    #[doc = ""]
    #[doc = " Memory which already allocated on peer device will be mapped into the address space of the"]
    #[doc = " current device.  In addition, all future memory allocations on peerDeviceId will be mapped into"]
    #[doc = " the address space of the current device when the memory is allocated. The peer memory remains"]
    #[doc = " accessible from the current device until a call to hipDeviceDisablePeerAccess or hipDeviceReset."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param [in] peerCtx"]
    #[doc = " @param [in] flags"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue,"]
    #[doc = " #hipErrorPeerAccessAlreadyEnabled"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    #[doc = " @warning PeerToPeer support is experimental."]
    pub fn hipCtxEnablePeerAccess(peerCtx: hipCtx_t, flags: ::std::os::raw::c_uint) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Disable direct access from current context's virtual address space to memory allocations"]
    #[doc = " physically located on a peer context.Disables direct access to memory allocations in a peer"]
    #[doc = " context and unregisters any registered allocations."]
    #[doc = ""]
    #[doc = " Returns hipErrorPeerAccessNotEnabled if direct access to memory on peerDevice has not yet been"]
    #[doc = " enabled from the current device."]
    #[doc = ""]
    #[doc = " @param [in] peerCtx"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorPeerAccessNotEnabled"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    #[doc = " @warning PeerToPeer support is experimental."]
    pub fn hipCtxDisablePeerAccess(peerCtx: hipCtx_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get the state of the primary context."]
    #[doc = ""]
    #[doc = " @param [in] Device to get primary context flags for"]
    #[doc = " @param [out] Pointer to store flags"]
    #[doc = " @param [out] Pointer to store context state; 0 = inactive, 1 = active"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipDevicePrimaryCtxGetState(
        dev: hipDevice_t,
        flags: *mut ::std::os::raw::c_uint,
        active: *mut ::std::os::raw::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Release the primary context on the GPU."]
    #[doc = ""]
    #[doc = " @param [in] Device which primary context is released"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    #[doc = " @warning This function return #hipSuccess though doesn't release the primaryCtx by design on"]
    #[doc = " HIP/HCC path."]
    pub fn hipDevicePrimaryCtxRelease(dev: hipDevice_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Retain the primary context on the GPU."]
    #[doc = ""]
    #[doc = " @param [out] Returned context handle of the new context"]
    #[doc = " @param [in] Device which primary context is released"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipDevicePrimaryCtxRetain(pctx: *mut hipCtx_t, dev: hipDevice_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Resets the primary context on the GPU."]
    #[doc = ""]
    #[doc = " @param [in] Device which primary context is reset"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipDevicePrimaryCtxReset(dev: hipDevice_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set flags for the primary context."]
    #[doc = ""]
    #[doc = " @param [in] Device for which the primary context flags are set"]
    #[doc = " @param [in] New flags for the device"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorContextAlreadyInUse"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipDevicePrimaryCtxSetFlags(
        dev: hipDevice_t,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Loads code object from file into a hipModule_t"]
    #[doc = ""]
    #[doc = " @param [in] fname"]
    #[doc = " @param [out] module"]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipErrorInvalidValue, hipErrorInvalidContext, hipErrorFileNotFound,"]
    #[doc = " hipErrorOutOfMemory, hipErrorSharedObjectInitFailed, hipErrorNotInitialized"]
    #[doc = ""]
    #[doc = ""]
    pub fn hipModuleLoad(
        module: *mut hipModule_t,
        fname: *const ::std::os::raw::c_char,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Frees the module"]
    #[doc = ""]
    #[doc = " @param [in] module"]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipInvalidValue"]
    #[doc = " module is freed and the code objects associated with it are destroyed"]
    #[doc = ""]
    pub fn hipModuleUnload(module: hipModule_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Function with kname will be extracted if present in module"]
    #[doc = ""]
    #[doc = " @param [in] module"]
    #[doc = " @param [in] kname"]
    #[doc = " @param [out] function"]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipErrorInvalidValue, hipErrorInvalidContext, hipErrorNotInitialized,"]
    #[doc = " hipErrorNotFound,"]
    pub fn hipModuleGetFunction(
        function: *mut hipFunction_t,
        module: hipModule_t,
        kname: *const ::std::os::raw::c_char,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Find out attributes for a given function."]
    #[doc = ""]
    #[doc = " @param [out] attr"]
    #[doc = " @param [in] func"]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipErrorInvalidValue, hipErrorInvalidDeviceFunction"]
    pub fn hipFuncGetAttributes(
        attr: *mut hipFuncAttributes,
        func: *const ::std::os::raw::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Find out a specific attribute for a given function."]
    #[doc = ""]
    #[doc = " @param [out] value"]
    #[doc = " @param [in]  attrib"]
    #[doc = " @param [in]  hfunc"]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipErrorInvalidValue, hipErrorInvalidDeviceFunction"]
    pub fn hipFuncGetAttribute(
        value: *mut ::std::os::raw::c_int,
        attrib: hipFunction_attribute,
        hfunc: hipFunction_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief returns the handle of the texture reference with the name from the module."]
    #[doc = ""]
    #[doc = " @param [in] hmod"]
    #[doc = " @param [in] name"]
    #[doc = " @param [out] texRef"]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipErrorNotInitialized, hipErrorNotFound, hipErrorInvalidValue"]
    pub fn hipModuleGetTexRef(
        texRef: *mut *mut textureReference,
        hmod: hipModule_t,
        name: *const ::std::os::raw::c_char,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief builds module from code object which resides in host memory. Image is pointer to that"]
    #[doc = " location."]
    #[doc = ""]
    #[doc = " @param [in] image"]
    #[doc = " @param [out] module"]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipErrorNotInitialized, hipErrorOutOfMemory, hipErrorNotInitialized"]
    pub fn hipModuleLoadData(
        module: *mut hipModule_t,
        image: *const ::std::os::raw::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief builds module from code object which resides in host memory. Image is pointer to that"]
    #[doc = " location. Options are not used. hipModuleLoadData is called."]
    #[doc = ""]
    #[doc = " @param [in] image"]
    #[doc = " @param [out] module"]
    #[doc = " @param [in] number of options"]
    #[doc = " @param [in] options for JIT"]
    #[doc = " @param [in] option values for JIT"]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipErrorNotInitialized, hipErrorOutOfMemory, hipErrorNotInitialized"]
    pub fn hipModuleLoadDataEx(
        module: *mut hipModule_t,
        image: *const ::std::os::raw::c_void,
        numOptions: ::std::os::raw::c_uint,
        options: *mut hipJitOption,
        optionValues: *mut *mut ::std::os::raw::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief launches kernel f with launch parameters and shared memory on stream with arguments passed"]
    #[doc = " to kernelparams or extra"]
    #[doc = ""]
    #[doc = " @param [in] f         Kernel to launch."]
    #[doc = " @param [in] gridDimX  X grid dimension specified as multiple of blockDimX."]
    #[doc = " @param [in] gridDimY  Y grid dimension specified as multiple of blockDimY."]
    #[doc = " @param [in] gridDimZ  Z grid dimension specified as multiple of blockDimZ."]
    #[doc = " @param [in] blockDimX X block dimensions specified in work-items"]
    #[doc = " @param [in] blockDimY Y grid dimension specified in work-items"]
    #[doc = " @param [in] blockDimZ Z grid dimension specified in work-items"]
    #[doc = " @param [in] sharedMemBytes Amount of dynamic shared memory to allocate for this kernel. The"]
    #[doc = " HIP-Clang compiler provides support for extern shared declarations."]
    #[doc = " @param [in] stream    Stream where the kernel should be dispatched.  May be 0, in which case th"]
    #[doc = " default stream is used with associated synchronization rules."]
    #[doc = " @param [in] kernelParams"]
    #[doc = " @param [in] extra     Pointer to kernel arguments.   These are passed directly to the kernel and"]
    #[doc = " must be in the memory layout and alignment expected by the kernel."]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = " @warning kernellParams argument is not yet implemented in HIP. Please use extra instead. Please"]
    #[doc = " refer to hip_porting_driver_api.md for sample usage."]
    pub fn hipModuleLaunchKernel(
        f: hipFunction_t,
        gridDimX: ::std::os::raw::c_uint,
        gridDimY: ::std::os::raw::c_uint,
        gridDimZ: ::std::os::raw::c_uint,
        blockDimX: ::std::os::raw::c_uint,
        blockDimY: ::std::os::raw::c_uint,
        blockDimZ: ::std::os::raw::c_uint,
        sharedMemBytes: ::std::os::raw::c_uint,
        stream: hipStream_t,
        kernelParams: *mut *mut ::std::os::raw::c_void,
        extra: *mut *mut ::std::os::raw::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief launches kernel f with launch parameters and shared memory on stream with arguments passed"]
    #[doc = " to kernelparams or extra, where thread blocks can cooperate and synchronize as they execute"]
    #[doc = ""]
    #[doc = " @param [in] f         Kernel to launch."]
    #[doc = " @param [in] gridDim   Grid dimensions specified as multiple of blockDim."]
    #[doc = " @param [in] blockDim  Block dimensions specified in work-items"]
    #[doc = " @param [in] kernelParams A list of kernel arguments"]
    #[doc = " @param [in] sharedMemBytes Amount of dynamic shared memory to allocate for this kernel. The"]
    #[doc = " HIP-Clang compiler provides support for extern shared declarations."]
    #[doc = " @param [in] stream    Stream where the kernel should be dispatched.  May be 0, in which case th"]
    #[doc = " default stream is used with associated synchronization rules."]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue, hipErrorCooperativeLaunchTooLarge"]
    pub fn hipLaunchCooperativeKernel(
        f: *const ::std::os::raw::c_void,
        gridDim: dim3,
        blockDimX: dim3,
        kernelParams: *mut *mut ::std::os::raw::c_void,
        sharedMemBytes: ::std::os::raw::c_uint,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Launches kernels on multiple devices where thread blocks can cooperate and"]
    #[doc = " synchronize as they execute."]
    #[doc = ""]
    #[doc = " @param [in] hipLaunchParams          List of launch parameters, one per device."]
    #[doc = " @param [in] numDevices               Size of the launchParamsList array."]
    #[doc = " @param [in] flags                    Flags to control launch behavior."]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue, hipErrorCooperativeLaunchTooLarge"]
    pub fn hipLaunchCooperativeKernelMultiDevice(
        launchParamsList: *mut hipLaunchParams,
        numDevices: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Launches kernels on multiple devices and guarantees all specified kernels are dispatched"]
    #[doc = " on respective streams before enqueuing any other work on the specified streams from any other threads"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param [in] hipLaunchParams          List of launch parameters, one per device."]
    #[doc = " @param [in] numDevices               Size of the launchParamsList array."]
    #[doc = " @param [in] flags                    Flags to control launch behavior."]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue"]
    pub fn hipExtLaunchMultiKernelMultiDevice(
        launchParamsList: *mut hipLaunchParams,
        numDevices: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief determine the grid and block sizes to achieves maximum occupancy for a kernel"]
    #[doc = ""]
    #[doc = " @param [out] gridSize           minimum grid size for maximum potential occupancy"]
    #[doc = " @param [out] blockSize          block size for maximum potential occupancy"]
    #[doc = " @param [in]  f                  kernel function for which occupancy is calulated"]
    #[doc = " @param [in]  dynSharedMemPerBlk dynamic shared memory usage (in bytes) intended for each block"]
    #[doc = " @param [in]  blockSizeLimit     the maximum block size for the kernel, use 0 for no limit"]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipInvalidDevice, hipErrorInvalidValue"]
    pub fn hipModuleOccupancyMaxPotentialBlockSize(
        gridSize: *mut ::std::os::raw::c_int,
        blockSize: *mut ::std::os::raw::c_int,
        f: hipFunction_t,
        dynSharedMemPerBlk: usize,
        blockSizeLimit: ::std::os::raw::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief determine the grid and block sizes to achieves maximum occupancy for a kernel"]
    #[doc = ""]
    #[doc = " @param [out] gridSize           minimum grid size for maximum potential occupancy"]
    #[doc = " @param [out] blockSize          block size for maximum potential occupancy"]
    #[doc = " @param [in]  f                  kernel function for which occupancy is calulated"]
    #[doc = " @param [in]  dynSharedMemPerBlk dynamic shared memory usage (in bytes) intended for each block"]
    #[doc = " @param [in]  blockSizeLimit     the maximum block size for the kernel, use 0 for no limit"]
    #[doc = " @param [in]  flags            Extra flags for occupancy calculation (only default supported)"]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipInvalidDevice, hipErrorInvalidValue"]
    pub fn hipModuleOccupancyMaxPotentialBlockSizeWithFlags(
        gridSize: *mut ::std::os::raw::c_int,
        blockSize: *mut ::std::os::raw::c_int,
        f: hipFunction_t,
        dynSharedMemPerBlk: usize,
        blockSizeLimit: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns occupancy for a device function."]
    #[doc = ""]
    #[doc = " @param [out] numBlocks        Returned occupancy"]
    #[doc = " @param [in]  func             Kernel function (hipFunction) for which occupancy is calulated"]
    #[doc = " @param [in]  blockSize        Block size the kernel is intended to be launched with"]
    #[doc = " @param [in]  dynSharedMemPerBlk dynamic shared memory usage (in bytes) intended for each block"]
    pub fn hipModuleOccupancyMaxActiveBlocksPerMultiprocessor(
        numBlocks: *mut ::std::os::raw::c_int,
        f: hipFunction_t,
        blockSize: ::std::os::raw::c_int,
        dynSharedMemPerBlk: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns occupancy for a device function."]
    #[doc = ""]
    #[doc = " @param [out] numBlocks        Returned occupancy"]
    #[doc = " @param [in]  f                Kernel function(hipFunction_t) for which occupancy is calulated"]
    #[doc = " @param [in]  blockSize        Block size the kernel is intended to be launched with"]
    #[doc = " @param [in]  dynSharedMemPerBlk dynamic shared memory usage (in bytes) intended for each block"]
    #[doc = " @param [in]  flags            Extra flags for occupancy calculation (only default supported)"]
    pub fn hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(
        numBlocks: *mut ::std::os::raw::c_int,
        f: hipFunction_t,
        blockSize: ::std::os::raw::c_int,
        dynSharedMemPerBlk: usize,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns occupancy for a device function."]
    #[doc = ""]
    #[doc = " @param [out] numBlocks        Returned occupancy"]
    #[doc = " @param [in]  func             Kernel function for which occupancy is calulated"]
    #[doc = " @param [in]  blockSize        Block size the kernel is intended to be launched with"]
    #[doc = " @param [in]  dynSharedMemPerBlk dynamic shared memory usage (in bytes) intended for each block"]
    pub fn hipOccupancyMaxActiveBlocksPerMultiprocessor(
        numBlocks: *mut ::std::os::raw::c_int,
        f: *const ::std::os::raw::c_void,
        blockSize: ::std::os::raw::c_int,
        dynSharedMemPerBlk: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns occupancy for a device function."]
    #[doc = ""]
    #[doc = " @param [out] numBlocks        Returned occupancy"]
    #[doc = " @param [in]  f                Kernel function for which occupancy is calulated"]
    #[doc = " @param [in]  blockSize        Block size the kernel is intended to be launched with"]
    #[doc = " @param [in]  dynSharedMemPerBlk dynamic shared memory usage (in bytes) intended for each block"]
    #[doc = " @param [in]  flags            Extra flags for occupancy calculation (currently ignored)"]
    pub fn hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(
        numBlocks: *mut ::std::os::raw::c_int,
        f: *const ::std::os::raw::c_void,
        blockSize: ::std::os::raw::c_int,
        dynSharedMemPerBlk: usize,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief determine the grid and block sizes to achieves maximum occupancy for a kernel"]
    #[doc = ""]
    #[doc = " @param [out] gridSize           minimum grid size for maximum potential occupancy"]
    #[doc = " @param [out] blockSize          block size for maximum potential occupancy"]
    #[doc = " @param [in]  f                  kernel function for which occupancy is calulated"]
    #[doc = " @param [in]  dynSharedMemPerBlk dynamic shared memory usage (in bytes) intended for each block"]
    #[doc = " @param [in]  blockSizeLimit     the maximum block size for the kernel, use 0 for no limit"]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipInvalidDevice, hipErrorInvalidValue"]
    pub fn hipOccupancyMaxPotentialBlockSize(
        gridSize: *mut ::std::os::raw::c_int,
        blockSize: *mut ::std::os::raw::c_int,
        f: *const ::std::os::raw::c_void,
        dynSharedMemPerBlk: usize,
        blockSizeLimit: ::std::os::raw::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Start recording of profiling information"]
    #[doc = " When using this API, start the profiler with profiling disabled.  (--startdisabled)"]
    #[doc = " @warning : hipProfilerStart API is under development."]
    pub fn hipProfilerStart() -> hipError_t;
}
extern "C" {
    #[doc = " @brief Stop recording of profiling information."]
    #[doc = " When using this API, start the profiler with profiling disabled.  (--startdisabled)"]
    #[doc = " @warning : hipProfilerStop API is under development."]
    pub fn hipProfilerStop() -> hipError_t;
}
extern "C" {
    #[doc = " @brief Configure a kernel launch."]
    #[doc = ""]
    #[doc = " @param [in] gridDim   grid dimension specified as multiple of blockDim."]
    #[doc = " @param [in] blockDim  block dimensions specified in work-items"]
    #[doc = " @param [in] sharedMem Amount of dynamic shared memory to allocate for this kernel. The"]
    #[doc = " HIP-Clang compiler provides support for extern shared declarations."]
    #[doc = " @param [in] stream    Stream where the kernel should be dispatched.  May be 0, in which case the"]
    #[doc = " default stream is used with associated synchronization rules."]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue"]
    #[doc = ""]
    pub fn hipConfigureCall(
        gridDim: dim3,
        blockDim: dim3,
        sharedMem: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set a kernel argument."]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = " @param [in] arg    Pointer the argument in host memory."]
    #[doc = " @param [in] size   Size of the argument."]
    #[doc = " @param [in] offset Offset of the argument on the argument stack."]
    #[doc = ""]
    pub fn hipSetupArgument(
        arg: *const ::std::os::raw::c_void,
        size: usize,
        offset: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Launch a kernel."]
    #[doc = ""]
    #[doc = " @param [in] func Kernel to launch."]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue"]
    #[doc = ""]
    pub fn hipLaunchByPtr(func: *const ::std::os::raw::c_void) -> hipError_t;
}
extern "C" {
    #[doc = " @brief C compliant kernel launch API"]
    #[doc = ""]
    #[doc = " @param [in] function_address - kernel stub function pointer."]
    #[doc = " @param [in] numBlocks - number of blocks"]
    #[doc = " @param [in] dimBlocks - dimension of a block"]
    #[doc = " @param [in] args - kernel arguments"]
    #[doc = " @param [in] sharedMemBytes - Amount of dynamic shared memory to allocate for this kernel. The"]
    #[doc = " HIP-Clang compiler provides support for extern shared declarations."]
    #[doc = " @param [in] stream - Stream where the kernel should be dispatched.  May be 0, in which case th"]
    #[doc = "  default stream is used with associated synchronization rules."]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidValue, hipInvalidDevice"]
    #[doc = ""]
    pub fn hipLaunchKernel(
        function_address: *const ::std::os::raw::c_void,
        numBlocks: dim3,
        dimBlocks: dim3,
        args: *mut *mut ::std::os::raw::c_void,
        sharedMemBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " Copies memory for 2D arrays."]
    #[doc = ""]
    #[doc = " @param pCopy           - Parameters for the memory copy"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipDrvMemcpy2DUnaligned(pCopy: *const hip_Memcpy2D) -> hipError_t;
}
extern "C" {
    pub fn hipExtLaunchKernel(
        function_address: *const ::std::os::raw::c_void,
        numBlocks: dim3,
        dimBlocks: dim3,
        args: *mut *mut ::std::os::raw::c_void,
        sharedMemBytes: usize,
        stream: hipStream_t,
        startEvent: hipEvent_t,
        stopEvent: hipEvent_t,
        flags: ::std::os::raw::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @addtogroup TexturD Texture Management [Deprecated]"]
    #[doc = "  @{"]
    #[doc = "  @ingroup Texture"]
    #[doc = "  This section describes the deprecated texture management functions of HIP runtime API."]
    pub fn hipBindTexture(
        offset: *mut usize,
        tex: *const textureReference,
        devPtr: *const ::std::os::raw::c_void,
        desc: *const hipChannelFormatDesc,
        size: usize,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipBindTexture2D(
        offset: *mut usize,
        tex: *const textureReference,
        devPtr: *const ::std::os::raw::c_void,
        desc: *const hipChannelFormatDesc,
        width: usize,
        height: usize,
        pitch: usize,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipBindTextureToArray(
        tex: *const textureReference,
        array: hipArray_const_t,
        desc: *const hipChannelFormatDesc,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipGetTextureAlignmentOffset(
        offset: *mut usize,
        texref: *const textureReference,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipUnbindTexture(tex: *const textureReference) -> hipError_t;
}
extern "C" {
    #[doc = " @}"]
    pub fn hipBindTextureToMipmappedArray(
        tex: *const textureReference,
        mipmappedArray: hipMipmappedArray_const_t,
        desc: *const hipChannelFormatDesc,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipGetTextureReference(
        texref: *mut *const textureReference,
        symbol: *const ::std::os::raw::c_void,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipCreateTextureObject(
        pTexObject: *mut hipTextureObject_t,
        pResDesc: *const hipResourceDesc,
        pTexDesc: *const hipTextureDesc,
        pResViewDesc: *const hipResourceViewDesc,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipDestroyTextureObject(textureObject: hipTextureObject_t) -> hipError_t;
}
extern "C" {
    pub fn hipGetChannelDesc(
        desc: *mut hipChannelFormatDesc,
        array: hipArray_const_t,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipGetTextureObjectResourceDesc(
        pResDesc: *mut hipResourceDesc,
        textureObject: hipTextureObject_t,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipGetTextureObjectResourceViewDesc(
        pResViewDesc: *mut hipResourceViewDesc,
        textureObject: hipTextureObject_t,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipGetTextureObjectTextureDesc(
        pTexDesc: *mut hipTextureDesc,
        textureObject: hipTextureObject_t,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipTexRefGetAddress(
        dev_ptr: *mut hipDeviceptr_t,
        texRef: *const textureReference,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipTexRefGetAddressMode(
        pam: *mut hipTextureAddressMode,
        texRef: *const textureReference,
        dim: ::std::os::raw::c_int,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipTexRefGetFilterMode(
        pfm: *mut hipTextureFilterMode,
        texRef: *const textureReference,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipTexRefGetFlags(
        pFlags: *mut ::std::os::raw::c_uint,
        texRef: *const textureReference,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipTexRefGetFormat(
        pFormat: *mut hipArray_Format,
        pNumChannels: *mut ::std::os::raw::c_int,
        texRef: *const textureReference,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipTexRefGetMaxAnisotropy(
        pmaxAnsio: *mut ::std::os::raw::c_int,
        texRef: *const textureReference,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipTexRefGetMipmapFilterMode(
        pfm: *mut hipTextureFilterMode,
        texRef: *const textureReference,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipTexRefGetMipmapLevelBias(
        pbias: *mut f32,
        texRef: *const textureReference,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipTexRefGetMipmapLevelClamp(
        pminMipmapLevelClamp: *mut f32,
        pmaxMipmapLevelClamp: *mut f32,
        texRef: *const textureReference,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipTexRefGetMipMappedArray(
        pArray: *mut hipMipmappedArray_t,
        texRef: *const textureReference,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipTexRefSetAddress(
        ByteOffset: *mut usize,
        texRef: *mut textureReference,
        dptr: hipDeviceptr_t,
        bytes: usize,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipTexRefSetAddress2D(
        texRef: *mut textureReference,
        desc: *const HIP_ARRAY_DESCRIPTOR,
        dptr: hipDeviceptr_t,
        Pitch: usize,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipTexRefSetAddressMode(
        texRef: *mut textureReference,
        dim: ::std::os::raw::c_int,
        am: hipTextureAddressMode,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipTexRefSetArray(
        tex: *mut textureReference,
        array: hipArray_const_t,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipTexRefSetFilterMode(
        texRef: *mut textureReference,
        fm: hipTextureFilterMode,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipTexRefSetFlags(
        texRef: *mut textureReference,
        Flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipTexRefSetFormat(
        texRef: *mut textureReference,
        fmt: hipArray_Format,
        NumPackedComponents: ::std::os::raw::c_int,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipTexRefSetMaxAnisotropy(
        texRef: *mut textureReference,
        maxAniso: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipTexObjectCreate(
        pTexObject: *mut hipTextureObject_t,
        pResDesc: *const HIP_RESOURCE_DESC,
        pTexDesc: *const HIP_TEXTURE_DESC,
        pResViewDesc: *const HIP_RESOURCE_VIEW_DESC,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipTexObjectDestroy(texObject: hipTextureObject_t) -> hipError_t;
}
extern "C" {
    pub fn hipTexObjectGetResourceDesc(
        pResDesc: *mut HIP_RESOURCE_DESC,
        texObject: hipTextureObject_t,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipTexObjectGetResourceViewDesc(
        pResViewDesc: *mut HIP_RESOURCE_VIEW_DESC,
        texObject: hipTextureObject_t,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipTexObjectGetTextureDesc(
        pTexDesc: *mut HIP_TEXTURE_DESC,
        texObject: hipTextureObject_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @}"]
    pub fn hipTexRefSetBorderColor(
        texRef: *mut textureReference,
        pBorderColor: *mut f32,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipTexRefSetMipmapFilterMode(
        texRef: *mut textureReference,
        fm: hipTextureFilterMode,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipTexRefSetMipmapLevelBias(texRef: *mut textureReference, bias: f32) -> hipError_t;
}
extern "C" {
    pub fn hipTexRefSetMipmapLevelClamp(
        texRef: *mut textureReference,
        minMipMapLevelClamp: f32,
        maxMipMapLevelClamp: f32,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipTexRefSetMipmappedArray(
        texRef: *mut textureReference,
        mipmappedArray: *mut hipMipmappedArray,
        Flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMipmappedArrayCreate(
        pHandle: *mut hipMipmappedArray_t,
        pMipmappedArrayDesc: *mut HIP_ARRAY3D_DESCRIPTOR,
        numMipmapLevels: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMipmappedArrayDestroy(hMipmappedArray: hipMipmappedArray_t) -> hipError_t;
}
extern "C" {
    pub fn hipMipmappedArrayGetLevel(
        pLevelArray: *mut hipArray_t,
        hMipMappedArray: hipMipmappedArray_t,
        level: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " Callback/Activity API"]
    pub fn hipRegisterApiCallback(
        id: u32,
        fun: *mut ::std::os::raw::c_void,
        arg: *mut ::std::os::raw::c_void,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipRemoveApiCallback(id: u32) -> hipError_t;
}
extern "C" {
    pub fn hipRegisterActivityCallback(
        id: u32,
        fun: *mut ::std::os::raw::c_void,
        arg: *mut ::std::os::raw::c_void,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipRemoveActivityCallback(id: u32) -> hipError_t;
}
extern "C" {
    pub fn hipApiName(id: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn hipKernelNameRef(f: hipFunction_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn hipKernelNameRefByPtr(
        hostFunction: *const ::std::os::raw::c_void,
        stream: hipStream_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn hipGetStreamDeviceId(stream: hipStream_t) -> ::std::os::raw::c_int;
}
